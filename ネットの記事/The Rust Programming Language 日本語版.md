## これはなに
- [The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/title-page.html)を読み直していくので、アウトプットまとめ
- 重要だと感じた点をピックアップ

## 第3章 一般的なプログラミングの概念
### 変数と可変性
- Rustにおいて、変数は標準で不変
	- mutをつけると可変に出来る
- 定数はconstで宣言し、型注釈を必ずつける
- すでに定義されている変数と同じ名前の変数を新しく宣言することをシャドーイングという
	- すでに定義されている変数は覆い隠され、使えなくなる
	- letを使わずに誤って変数に再代入を試みるとコンパイルエラーが発生する
		- letを使ってシャドーイングすることでちょっとした加工を加え、その加工が終われば変数は不変になる
	- mutとの違いは、実効的には新しい変数を生成していることになるので、値の型を変えつつ同じ変数名を使い回せる

### データ型
- 複数の型が推論される可能性がある場合は型注釈をつける必要がある
- Rustの整数型

| 大きさ    | 符号付き  | 符号なし  |
| ------ | ----- | ----- |
| 8-bit  | i8    | u8    |
| 16-bit | i16   | u16   |
| 32-bit | i32   | u32   |
| 64-bit | i64   | u64   |
| arch   | isize | usize |

- isizeとusizeは、プログラムが動作しているコンピュータの種類に依存
	- 64ビットアーキテクチャなら64ビット、32ビットアーキテクチャなら32ビットになる
- Rustの整数リテラル

| 数値リテラル    | 例           |
| --------- | ----------- |
| 10進数      | 98_222      |
| 16進数      | 0xff        |
| 8進数       | 0o77        |
| 2進数       | 0b1111_0000 |
| バイト（u8だけ） | b'A'        |

- どの整数型を使うべきか迷うとき、確信が持てないときは整数型の基準であるi32型を使うべき
	- 64ビットシステム上でもi32型が普通最速になる
	- isizeとusizeを使う主な状況は、何らかのコレクションにアクセスするとき
- Rustの浮動小数点型にはf32とf64があり、基準型はf64
	- 現代のCPUでは、f32とほぼ同じスピードにもかかわらず、より精度が高くなるから
	- f32が単精度浮動小数点数、f64が倍精度浮動小数点数
- タプル型の要素に直接アクセスしたい場合はピリオド（.）に続けてアクセスしたい値の番号を書く
- Rustの配列は固定長なので、一度宣言されるとサイズを伸ばしたり縮めたりできない
	- ヒープよりもスタックにデータのメモリを確保したいとき、常に固定長の要素があることを確認したい時に有効
- ベクターは標準ライブラリによって提供されている配列と似たようなコレクション型で、サイズを伸縮させることができる
- 配列とベクターのどちらを使うべきか確信が持てないときは、おそらくベクター型を使うべき
- 角かっこの中に初期値とセミコロン、配列の長さを与えることで各要素に同じ値を持つ配列を初期化できる
	- `let a = [3; 5];`
- 配列の終端を超えて要素にアクセスしようとした場合、コンパイルは通るが実行時エラーになる
	- 低レベル言語の多くではこういったチェックは行われないので、間違った添え字を与えると無効なメモリにアクセスできてしまう
	- Rustではメモリアクセスを許可し、処理を継続する代わりに即座にプログラムを終了することで、上記のような問題からプログラマーを保護している

### 関数
- Rustの関数と変数の命名規則はスネークケース
- Rustコンパイラは関数がどこで定義されているかは気にしない、どこかで定義されていることのみ気にする
- 関数シグネチャにおいて、各仮引数の型を宣言しなければならない
	- Rustの設計において意図的な判断
	- 引数に型注釈をつけておけば、コンパイラがその意図を理解しやすくなり、プログラマーがコードの他の場所で型注釈をつける必要がなくなる
- Rustは式指向言語
- 文とは、なんらかの動作をして値を返さない命令
	- letを使用して変数を生成し、値を代入することは文
	- 文を他の変数に代入することはできない
- 式は結果の値に評価される（なんらかの値を返す）
	- `5 + 6`のような演算は式（値11に評価される）、関数呼び出しも式、マクロ呼び出しも式、新しいスコープを作る際に使用するブロック（`{}`）も式
	- 式は終端にセミコロンを含まない（式の終端にセミコロンをつけると、文に変わってしまう）
- 関数の戻り値の型は、`method() -> i32`のように、`->`の後に必ず記述する必要がある
- 関数の戻り値は、関数本体ブロックの最後の式の値と同義
- returnで関数から早期リターンし、値を指定することも可能だが多くの関数は最後の式を暗黙的に返す

### コメント
- Rustでは、コメントは2連スラッシュで始め、行の終わりまで続く
- コメントが複数行にまたがる場合、各行に2連スラッシュを含める必要がある
- コードが書かれた行の末尾にも配置することが出来る
	- 注釈しようとしているコードの1行上に書く形式の方がベター

### 制御フロー
- if式の条件式と紐付けられる一連のコードは、アームと呼ばれることがある
	- match式のアームと同じ
- 条件式はbool型でなければならない
	- RubyやJavaScriptなどの言語とは異なり、Rustでは論理値以外の値が自動的に論理値に変換されることはない
- `else if`式を使い過ぎるとコードがめちゃくちゃになるので、1つ以上ある場合はmatchと呼ばれる機構を使うことを検討した方が良い
- loopを使用すると、明示的にやめさせるまで同じコードを実行する
	- ループ内にbreackを配置することで、プログラムに実行を終了すべきタイミングを教えることが出来る
	- continueはループの中で残っているコードをスキップして次のループに移るためのもの
	- ループ内にループがある場合、breakとcontinueは最も内側のループに適用される
	- ループラベルを使用することで、breakやcontinueが適用されるループを指定することが出来る

## 第4章 所有権
### 所有権とは？
- Rustの中心的な機能
- 値がスタックに積まれるかヒープに置かれるかは非常に重要
- スタックもヒープも、実行時にコードが使用できるメモリの一部
- スタックは、得た順番に値を並べ、逆の順で値を取り除いていく
	- last in, first out（最後に入れたものが最初に出てくる）
	- データへのアクセス方法のおかげでスタックは高速
	- スタック上のデータはすべて既知の固定サイズでなければならない
- コンパイル時にサイズが確定しなかったり、サイズが可変のデータはヒープに保存する
	- ヒープにデータを置くとき、OSはヒープ上に十分な大きさの空の領域を見つけて使用中にし、ポインタ（その場所のアドレス）を返す
		- この過程はallocating on the heap（ヒープに領域を確保する）と呼ばれ、単にallocateするなどと表現する
		- ヒープへのデータアクセスはポインタを追って目的の場所に到達しなくてはならないため、スタックのデータへのアクセスより低速
		- 現代のプロセッサは、メモリをあちこち行き来しなければより速くなる
		- ヒープに大きな領域を確保する行為も時間がかかることがある
- スタックに値を積むことはメモリ確保とは考えられない
- ポインタは既知の固定サイズなのでスタックに保管することができるが、実データが必要になった場合はポインタを辿る必要がある
- コードが関数を呼び出すと、関数に渡された値（ヒープへのデータへのポインタも含まれる可能性あり）と、関数のローカル変数がスタックに積まれる
	- 関数の実行が終了すると、それらの値はスタックから取り除かれる
- どの部分のコードがどのヒープ上のデータを使用しているか把握すること、ヒープ上の重複するデータを最小化すること、メモリ不足にならないようにヒープ上の未使用のデータを掃除することはすべて所有権が解決してくれる
- 変数がスコープを抜けるとき、`drop`関数が呼び出され、使われていないヒープメモリを片付けてくれる
- ヒープデータを格納している変数を別の変数に代入した場合、代入元の変数は使用できなくなる（ムーブ）
	- `Copy`トレイトに適合している型の場合、代入後も古い変数が使える
		- 整数型とか論理値型とかの単純なスカラー型
- スタック上のデータではなく、ヒープデータそのもののコピーが必要な場合は`clone`メソッドを使う
- 関数に引数として変数を渡すと、代入のようにコピーやムーブが行われ、所有権が移動する