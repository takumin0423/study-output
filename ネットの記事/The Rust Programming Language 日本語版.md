## これはなに
- [The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/title-page.html)を読み直していくので、アウトプットまとめ
- 重要だと感じた点をピックアップ

## 第3章
### 変数と可変性
- Rustにおいて、変数は標準で不変
	- mutをつけると可変に出来る
- 定数はconstで宣言し、型注釈を必ずつける
- すでに定義されている変数と同じ名前の変数を新しく宣言することをシャドーイングという
	- すでに定義されている変数は覆い隠され、使えなくなる
	- letを使わずに誤って変数に再代入を試みるとコンパイルエラーが発生する
		- letを使ってシャドーイングすることでちょっとした加工を加え、その加工が終われば変数は不変になる
	- mutとの違いは、実効的には新しい変数を生成していることになるので、値の型を変えつつ同じ変数名を使い回せる

### データ型
- 複数の型が推論される可能性がある場合は型注釈をつける必要がある
- Rustの整数型

| 大きさ    | 符号付き  | 符号なし  |
| ------ | ----- | ----- |
| 8-bit  | i8    | u8    |
| 16-bit | i16   | u16   |
| 32-bit | i32   | u32   |
| 64-bit | i64   | u64   |
| arch   | isize | usize |

- isizeとusizeは、プログラムが動作しているコンピュータの種類に依存
	- 64ビットアーキテクチャなら64ビット、32ビットアーキテクチャなら32ビットになる
- Rustの整数リテラル

| 数値リテラル    | 例           |
| --------- | ----------- |
| 10進数      | 98_222      |
| 16進数      | 0xff        |
| 8進数       | 0o77        |
| 2進数       | 0b1111_0000 |
| バイト（u8だけ） | b'A'        |

- どの整数型を使うべきか迷うとき、確信が持てないときは整数型の基準であるi32型を使うべき
	- 64ビットシステム上でもi32型が普通最速になる
	- isizeとusizeを使う主な状況は、何らかのコレクションにアクセスするとき
- Rustの浮動小数点型にはf32とf64があり、基準型はf64
	- 現代のCPUでは、f32とほぼ同じスピードにもかかわらず、より精度が高くなるから
	- f32が単精度浮動小数点数、f64が倍精度浮動小数点数
- タプル型の要素に直接アクセスしたい場合はピリオド（.）に続けてアクセスしたい値の番号を書く
- Rustの配列は固定長なので、一度宣言されるとサイズを伸ばしたり縮めたりできない
	- ヒープよりもスタックにデータのメモリを確保したいとき、常に固定長の要素があることを確認したい時に有効
- ベクターは標準ライブラリによって提供されている配列と似たようなコレクション型で、サイズを伸縮させることができる
- 配列とベクターのどちらを使うべきか確信が持てないときは、おそらくベクター型を使うべき
- 角かっこの中に初期値とセミコロン、配列の長さを与えることで各要素に同じ値を持つ配列を初期化できる
	- `let a = [3; 5];`
- 配列の終端を超えて要素にアクセスしようとした場合、コンパイルは通るが実行時エラーになる
	- 低レベル言語の多くではこういったチェックは行われないので、間違った添え字を与えると無効なメモリにアクセスできてしまう
	- Rustではメモリアクセスを許可し、処理を継続する代わりに即座にプログラムを終了することで、上記のような問題からプログラマーを保護している