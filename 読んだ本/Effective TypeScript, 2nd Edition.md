## これはなに
- 重要だと感じた部分の読書メモ
- 読んだら追記する

## 1. TypeScriptについて知ろう
### TypeScriptとJavaScriptの関係を理解する
- TypeScriptはJavaScriptのスーパーセット
	- すべてのJavaScriptプログラムは構文的に有効なTypeScriptプログラムだが、すべてのTypeScriptプログラムが有効なJavaScriptプログラムであるわけではない
- TypeScriptは、JavaScriptの実行時の動作をモデル化する静的型システムを追加し、実行時に例外をスローする可能性のあるコードを検出しようとする
	- コードが型チェッカーを通過しても、実行時にエラーをスローする可能性がある
- TypeScriptは、引数の数が間違っている関数呼び出しのような、法的だが疑わしいJavaScriptの構文を禁止する
- 型注釈は、TypeScriptにプログラマーの意図を伝え、正しいコードと誤ったコードを区別するのに役立つ

### 自分が使用しているTypeScriptのオプションを把握する
- TypeScriptコンパイラには、言語の核心的な側面に影響を与えるいくつかの設定がある
	- `noImplicitAny`
	- `strictNullChecks`
- コマンドラインオプションではなく、tsconfig.jsonを使用してTypeScriptを設定する
- JavaScriptプロジェクトをTypeScriptに移行している場合を除き、 `noImplicitAny`をオンにする
- `strictNullChecks`を使用して、「undefined is not an object」型の実行時エラーを防ぐ
- TypeScriptが提供する最も徹底的なチェックを受けるために、 `strict`を有効にすることを目指す

### コード生成は型から独立していることを理解する
- コード生成は型システムとは独立している
	- TypeScriptの型はコードの実行時の動作に影響を与えることはない
- 型エラーがあるプログラムでもコードを生成（コンパイル）することができる
- TypeScriptの型は実行時には利用できない
	- 実行時に型をクエリするには、型を再構築する方法が必要
		- タグ付きユニオン
		- プロパティチェック
- クラスのような構文は、TypeScriptの型と実行時に利用できる値の両方を導入する
- TypeScriptの型はコンパイルの一部として削除されるため、実行時のパフォーマンスに影響を与えることはない

### 構造的型付けに慣れる
- JavaScriptはダックタイピングであり、TypeScriptはこれをモデル化するために構造的型付けを使用する
	- インターフェースに割り当て可能な値は、型宣言に明示的にリストされているプロパティ以上のものを持つ場合がある
- クラスも構造的型付けのルールに従う
	- 予期しているクラスのインスタンスが得られない可能性がある
- 構造的型付けを使用して、ユニットテストを容易にすることができる

### any型の使用を制限する
- TypeScriptのany型は、型チェックのほとんどを無効にできる
- any型は型の安全性を排除し、契約を破り、開発者の体験を損ない、リファクタリングの際にエラーが発生させやすくし、型設計を隠し、型システムへの信頼を損ねる
- できるだけanyの使用は避ける

## 2. TypeScriptの型システム
### エディタを使用して型システムを調査し、探求する
- TypeScriptの言語サービスを活用するために、それらをサポートするエディタを使用する
- エディタを使って、型システムがどのように機能し、TypeScriptがどのように型を推論するかについての直感を養う
- TypeScriptのリファクタリングツールに慣れ親しむ
	- シンボルやファイルの名前変更など
- 型宣言ファイルにジャンプし、どのように挙動をモデル化しているかを確認する方法を把握する

### 型を値の集合として考える
- 型を値の集合（型のドメイン）として考える
	- これらの集合は有限であることもあれば（boolean型やリテラル型）、無限であることもある（number型やstring型）
- TypeScriptの型は厳密な階層ではなく、交差する集合（ベン図）を形成する
	- 2つの型は、互いにサブタイプでなくても重なることがある
- オブジェクトは型宣言に記載されていない追加のプロパティを持っていても、型に属することがある
- 型操作は集合のドメインに適用される
	- `A | B`のドメインは、AとBのドメインの和集合
- 「extends」「assignable to」「subtype to」を「subset of」の同義語として考える

### 記号が型空間にあるのか値空間にあるのかを判別する方法を知る
- TypeScriptの式を読んでいるとき、型空間と値空間のどちらにいるかを見分ける方法を知っておく
	- TypeScriptプレイグラウンド
- すべての値には静的型があるが、これは型空間でのみアクセスできる
	- 型やインターフェースのような型空間の構造は消去され、値空間ではアクセスできない
- クラスや列挙型のような一部の構造は、型と値の両方を導入する
- `typeof`, `this`, その他多くの演算子やキーワードは、型空間と値空間で異なる意味を持つ

### 型アサーションより型注釈を優先する
- 型注釈（`: Type`）を型アサーション（`as Type`）よりも優先して使用する
- アロー関数の戻り値の型をどのようにアノテートするかを知っておく
- 型アサーションや非nullアサーションは、TypeScriptが知らない型について何かを知っている場合にのみ使用する
- 型アサーションを使用する場合は、それが有効である理由を説明するコメントを残す

### オブジェクトラッパー型（String, Number, Boolean, Symbol, BigInt）を避ける
- TypeScriptのオブジェクトラッパー型は使用を避け、プリミティブ型を使用する
- オブジェクトラッパー型がプリミティブ型にメソッドを提供する方法を理解する
	- オブジェクトラッパー型を直接インスタンス化したり使用するのは避けるべきだが、SymbolとBigIntは例外

### 余分なプロパティチェックと型チェックを区別する
- オブジェクトリテラルを既知の型の変数に代入したり、関数に引数として渡すと余分なプロパティチェックが行われる
	- 余分なプロパティチェックはエラーを見つけるための効果的な方法だが、TypeScriptの型チェッカーが行う通常の構造的な代入可能性チェックとは異なる
		- これらのプロセスを混同すると、代入可能性のメンタルモデルを構築するのが難しくなるので注意
		- TypeScriptの構造的型付けは「閉じていない」
- 余分なプロパティチェックの限界を理解する
	- 中間変数を導入すると、これらのチェックが削除される
- 「弱い型」はオプショナルなプロパティのみを持つオブジェクト型
	- これらの型の場合、代入可能性チェックには少なくとも1つの一致するプロパティが必要

### 可能な場合は関数式全体に型を適用する
- パラメーターや戻り値の型に対してではなく、関数式全体に型注釈を適用することを検討する
- 同じ型シグネチャを繰り返し書いている場合は、関数型を抽出するか既存の型を探す
- ライブラリ作成者であれば、一般的なコールバックに対して型を提供する
- 他の関数のシグネチャに一致させるためには、 `typeof fn`を使用したり、戻り値の型を変更する必要がある場合は `Parameters`やrestパラメーターを使用する

### typeとinterfaceの違いを理解する
- `type`と `interface`の違いと相違点を理解する
- 両方の構文を使って同じ型を記述する方法を知っておく
- `interface`の宣言マージや、型のインライン化に注意する
- 確立されたスタイルがないプロジェクトでは、オブジェクト型には `interface`を優先する

### 変更に関連するエラーを回避するために `readonly`を使用する
- 関数がパラメータを変更しない場合は、配列には `readonly`を、オブジェクト型には `Readonly`を宣言する
	- 関数の契約が明確になり、実装での意図しない変更を防ぐことができる
- `readonly`と `Readonly`が浅いものであり、 `Readonly`はプロパティのみに影響し、メソッドには影響しない
- `readonly`を使用して変更に関するエラーを防ぎ、コード内で変更が発生する箇所を見つける
- `const`と `readonly`の違いを理解する
	- `const`は再代入を防ぎ、 `readonly`は変更を防ぐ

### 型操作とジェネリック型を使用して繰り返しを避ける
- DRY原則は、ロジックだけではなく型にも当てはまる
- 型を繰り返すのではなく、名前をつけて定義する
	- インターフェイスのフィールドを繰り返さないために `extends`を活用する
- TypeScriptが提供する型間のマッピングツール（`keyof`, `typeof`, インデックス型, マップ型など）を理解する
- ジェネリック型は型に対する関数に相当する
	- 型レベルの操作を繰り返すのではなく、ジェネリック型を使用して型をマッピングする
- 標準ライブラリで定義されているジェネリック型（`Pick`, `Partial`, `ReturnType`など）に慣れ親しむ
- DRYの適用を過剰に行わないように注意する
	- 共有するプロパティや型が本当に同じものであるかを確認する

### インデックスシグネチャよりもより正確な代替手段を優先する
- インデックスシグネチャの欠点を理解する
	- `any`と同様に型安全性を損ない、言語サービスの価値を低下させる
- 可能な限り、インデックスシグネチャよりもより正確な型を優先する
	- インターフェース、 `Map`, `Record`, マップ型、制約されたキー空間を持つインデックスシグネチャ

### 数値のインデックスシグネチャを避ける
- 配列はオブジェクトであり、そのキーは数値ではなく文字列であることを理解する
	- `number`をインデックスシグネチャとして使用するのは、バグを検出するためのTypeScriptの純粋な仕組み
- インデックスシグネチャに `number`を使用するのではなく、 `Array`, タプル, `ArrayLike`, `Iterable`型を優先する

## 3. 型推論と制御フロー解析
### 推論可能な型でコードを煩雑にしないようにする
- TypeScriptが同じ型を推論できる場合は、型アノテーションを記述しないようにする
- 理想的なTypeScriptのコードでは、関数やメソッドのシグネチャには型アノテーションを記述するが、ローカル変数には記述しない
- オブジェクトリテラルには明示的な型アノテーションを使用し、余分なプロパティチェックを有効にして、エラーが発生した場所に近い箇所で報告されるようにする
- 関数の戻り値の型は、複数の `return`文がある場合、パブリックAPIの一部である場合、特定の型を返すことを明示したい場合を除き、アノテーションしない

### 異なる型には異なる変数を使用する
- 変数の値は変わることがあるが、その型は基本的に変わらない
- 人間の読解や型チェッカーの混乱を避けるため、異なる型の値に同じ変数を再利用しないようにする

### 変数がどのようにして型を取得するかを理解する
- TypeScriptがリテラルから型を推論する際に、どのようにwideningするかを理解する
	- この動作に影響を与える方法を把握する
		- `const`, 型アノテーション, コンテキスト, ヘルパー関数, `as const`, `satisfies`など

### オブジェクトは一度に作成する
- オブジェクトは部分的にではなく、一度に構築することを優先する
- 型安全な方法でプロパティを追加するために、複数のオブジェクトやスプレッド構文を活用する
- プロパティを条件付きでオブジェクトに追加する方法を理解する

### 型の絞り込みを理解する
- TypeScriptが条件分岐やその他の制御フローに基づいて型を絞り込む仕組みを理解する
- 絞り込みを助けるために、タグ付きユニオン（判別可能なユニオン）やユーザー定義の型ガードを活用する
- TypeScriptが型の絞り込みをより容易に行えるよう、コードのリファクタリングを検討する

### エイリアスの使用は一貫性を保つ
- エイリアスの使用はTypeScriptの型の絞り込みを妨げる可能性がある
	- 変数にエイリアスを作成した場合は一貫して使用する
- 関数呼び出しがプロパティの型の絞り込みを無効にする可能性があることを理解する
	- プロパティよりもローカル変数の型の絞り込みを信用する

### 型推論におけるコンテキストの利用方法を理解する
- 型推論においてコンテキストがどのように利用されるかを理解する
- 変数を外部に切り出した際に型エラーが発生する場合は、型アノテーションを追加することを検討する
- 変数が完全に定数である場合は、 `as const`アサーションを使用する
	- ただし、これによりエラーが定義時ではなく使用時に現れる可能性があることに注意する
- 型アノテーションの必要性を減らすため、実用的であれば値をインラインで記述することを優先する

### 進化する型を理解する
- TypeScriptの型は通常、単に精緻化されるだけだが、 `null`, `undefined`, `[]`で初期化された型は進化することが許されている
	- この構造が発生する場所を認識し、自分のコードで型アノテーションの必要性を減らすために活用する
- より良いエラーチェックのために、進化する型を使うのではなく明示的な型アノテーションを提供することを検討する

### 型の流れを助けるために、関数型の構造やライブラリを活用する
- 組み込みの関数型構造や、Lodashのようなユーティリティライブラリの機能を使用し、自作の構造を避けることで型の流れを改善し可読性を高め、明示的な型アノテーションの必要性を減らす

### 型の流れを改善するために、コールバックの代わりに `async`関数を使用する
- より良い構成性と型の流れのために、コールバックよりも `Promise`を優先する
- 可能な限り、生の `Promise`よりも `async`/ `await`を優先する
	- それにより、より簡潔で分かりやすいコードになり、多くの種類のエラーを排除できる
- 関数が `Promise`を返す場合は、それを `async`と宣言する

### クラスとカリー化を使用して、新たな推論の場を構築する
- 型パラメータを複数持つ関数では、型推論は全て推論されるか、全て明示的に指定するかのどちらかになる
- 部分的な推論を得るためには、新しい推論の場を作成するためにクラスまたはカリー化を使用する
- ローカルな型エイリアスを作成したい場合は、カリー化のアプローチを優先する

## 4. 型設計
### 常に有効な状態を表す型を優先する
- 有効な状態と無効な状態の両方を表す型は混乱を招きやすく、エラーが発生しやすいコードにつながる可能性がある
- 常に有効な状態のみを表す型を優先する
	- たとえ表現が長くなったり難しくなったりしても、最終的には時間と労力の節約につながる

### 受け取るものには寛容に、生成するものは厳格に
- 入力の型は出力の型よりも広くなる傾向がある
	- パラメータの型ではオプションのプロパティやユニオン型が一般的だが、戻り値の型ではあまり使われない
- クライアントが使いにくくなるため、広すぎる戻り値の型は避ける
- パラメータと戻り値の型を再利用する場合は、戻り値の型として標準的な形式（カノニカルフォーム）を導入し、パラメータの型にはより緩い形式を採用する
- 関数のパラメータとして単にイテレーションを行う場合は、 `T[]`ではなく `Iterable<T>`を使用する

### ドキュメント内で型情報を繰り返さない
- コメントや変数名の中で型情報を繰り返さないようにする
	- 最良の場合でも型宣言と重複し、最悪の場合は矛盾した情報を生み出す可能性がある
- 変数を変更しないことをコメントで説明するのではなく、 `readonly`を使用して明示的に宣言する
- 型だけでは単位が明確でない場合、変数名に単位を含めることを検討する
	- timeMsやtemperatureCなど

### 型エイリアスに `null`や `undefined`を含めるのを避ける
- `null`や `undefined`を含む型エイリアスの定義は避ける

### `null`を型の周辺に押し出す
- ある値が `null`かどうかが、別の値が `null`かどうかと暗黙的に関連するような設計は避ける
- APIの周辺に `null`を押し出し、大きなオブジェクトを `null`または完全に非 `null`にする
	- これにより、人間の読者や型チェッカーにとってコードが明確になる
- 完全に非 `null`のクラスを作成し、すべての値が利用可能になったときに構築することを検討する