## これはなに
- 重要だと感じた部分の読書メモ
- 読んだら追記する

## 1. TypeScriptについて知ろう
### TypeScriptとJavaScriptの関係を理解する
- TypeScriptはJavaScriptのスーパーセット
	- すべてのJavaScriptプログラムは構文的に有効なTypeScriptプログラムだが、すべてのTypeScriptプログラムが有効なJavaScriptプログラムであるわけではない
- TypeScriptは、JavaScriptの実行時の動作をモデル化する静的型システムを追加し、実行時に例外をスローする可能性のあるコードを検出しようとする
	- コードが型チェッカーを通過しても、実行時にエラーをスローする可能性がある
- TypeScriptは、引数の数が間違っている関数呼び出しのような、法的だが疑わしいJavaScriptの構文を禁止する
- 型注釈は、TypeScriptにプログラマーの意図を伝え、正しいコードと誤ったコードを区別するのに役立つ

### 自分が使用しているTypeScriptのオプションを把握する
- TypeScriptコンパイラには、言語の核心的な側面に影響を与えるいくつかの設定がある
	- `noImplicitAny`
	- `strictNullChecks`
- コマンドラインオプションではなく、tsconfig.jsonを使用してTypeScriptを設定する
- JavaScriptプロジェクトをTypeScriptに移行している場合を除き、 `noImplicitAny`をオンにする
- `strictNullChecks`を使用して、「undefined is not an object」型の実行時エラーを防ぐ
- TypeScriptが提供する最も徹底的なチェックを受けるために、 `strict`を有効にすることを目指す

### コード生成は型から独立していることを理解する
- コード生成は型システムとは独立している
	- TypeScriptの型はコードの実行時の動作に影響を与えることはない
- 型エラーがあるプログラムでもコードを生成（コンパイル）することができる
- TypeScriptの型は実行時には利用できない
	- 実行時に型をクエリするには、型を再構築する方法が必要
		- タグ付きユニオン
		- プロパティチェック
- クラスのような構文は、TypeScriptの型と実行時に利用できる値の両方を導入する
- TypeScriptの型はコンパイルの一部として削除されるため、実行時のパフォーマンスに影響を与えることはない

### 構造的型付けに慣れる
- JavaScriptはダックタイピングであり、TypeScriptはこれをモデル化するために構造的型付けを使用する
	- インターフェースに割り当て可能な値は、型宣言に明示的にリストされているプロパティ以上のものを持つ場合がある
- クラスも構造的型付けのルールに従う
	- 予期しているクラスのインスタンスが得られない可能性がある
- 構造的型付けを使用して、ユニットテストを容易にすることができる

### any型の使用を制限する
- TypeScriptのany型は、型チェックのほとんどを無効にできる
- any型は型の安全性を排除し、契約を破り、開発者の体験を損ない、リファクタリングの際にエラーが発生させやすくし、型設計を隠し、型システムへの信頼を損ねる
- できるだけanyの使用は避ける

## 2. TypeScriptの型システム
### エディタを使用して型システムを調査し、探求する
- TypeScriptの言語サービスを活用するために、それらをサポートするエディタを使用する
- エディタを使って、型システムがどのように機能し、TypeScriptがどのように型を推論するかについての直感を養う
- TypeScriptのリファクタリングツールに慣れ親しむ
	- シンボルやファイルの名前変更など
- 型宣言ファイルにジャンプし、どのように挙動をモデル化しているかを確認する方法を把握する

### 型を値の集合として考える
- 型を値の集合（型のドメイン）として考える
	- これらの集合は有限であることもあれば（boolean型やリテラル型）、無限であることもある（number型やstring型）
- TypeScriptの型は厳密な階層ではなく、交差する集合（ベン図）を形成する
	- 2つの型は、互いにサブタイプでなくても重なることがある
- オブジェクトは型宣言に記載されていない追加のプロパティを持っていても、型に属することがある
- 型操作は集合のドメインに適用される
	- `A | B`のドメインは、AとBのドメインの和集合
- 「extends」「assignable to」「subtype to」を「subset of」の同義語として考える

### 記号が型空間にあるのか値空間にあるのかを判別する方法を知る
- TypeScriptの式を読んでいるとき、型空間と値空間のどちらにいるかを見分ける方法を知っておく
	- TypeScriptプレイグラウンド
- すべての値には静的型があるが、これは型空間でのみアクセスできる
	- 型やインターフェースのような型空間の構造は消去され、値空間ではアクセスできない
- クラスや列挙型のような一部の構造は、型と値の両方を導入する
- `typeof`, `this`, その他多くの演算子やキーワードは、型空間と値空間で異なる意味を持つ

### 型アサーションより型注釈を優先する
- 型注釈（`: Type`）を型アサーション（`as Type`）よりも優先して使用する
- アロー関数の戻り値の型をどのようにアノテートするかを知っておく
- 型アサーションや非nullアサーションは、TypeScriptが知らない型について何かを知っている場合にのみ使用する
- 型アサーションを使用する場合は、それが有効である理由を説明するコメントを残す

### オブジェクトラッパー型（String, Number, Boolean, Symbol, BigInt）を避ける
- TypeScriptのオブジェクトラッパー型は使用を避け、プリミティブ型を使用する
- オブジェクトラッパー型がプリミティブ型にメソッドを提供する方法を理解する
	- オブジェクトラッパー型を直接インスタンス化したり使用するのは避けるべきだが、SymbolとBigIntは例外

### 余分なプロパティチェックと型チェックを区別する
- オブジェクトリテラルを既知の型の変数に代入したり、関数に引数として渡すと余分なプロパティチェックが行われる
	- 余分なプロパティチェックはエラーを見つけるための効果的な方法だが、TypeScriptの型チェッカーが行う通常の構造的な代入可能性チェックとは異なる
		- これらのプロセスを混同すると、代入可能性のメンタルモデルを構築するのが難しくなるので注意
		- TypeScriptの構造的型付けは「閉じていない」
- 余分なプロパティチェックの限界を理解する
	- 中間変数を導入すると、これらのチェックが削除される
- 「弱い型」はオプショナルなプロパティのみを持つオブジェクト型
	- これらの型の場合、代入可能性チェックには少なくとも1つの一致するプロパティが必要

### 可能な場合は関数式全体に型を適用する
- パラメーターや戻り値の型に対してではなく、関数式全体に型注釈を適用することを検討する
- 同じ型シグネチャを繰り返し書いている場合は、関数型を抽出するか既存の型を探す
- ライブラリ作成者であれば、一般的なコールバックに対して型を提供する
- 他の関数のシグネチャに一致させるためには、 `typeof fn`を使用したり、戻り値の型を変更する必要がある場合は `Parameters`やrestパラメーターを使用する

### typeとinterfaceの違いを理解する
- `type`と `interface`の違いと相違点を理解する
- 両方の構文を使って同じ型を記述する方法を知っておく
- `interface`の宣言マージや、型のインライン化に注意する
- 確立されたスタイルがないプロジェクトでは、オブジェクト型には `interface`を優先する

### 変更に関連するエラーを回避するために `readonly`を使用する
- 関数がパラメータを変更しない場合は、配列には `readonly`を、オブジェクト型には `Readonly`を宣言する
	- 関数の契約が明確になり、実装での意図しない変更を防ぐことができる
- `readonly`と `Readonly`が浅いものであり、 `Readonly`はプロパティのみに影響し、メソッドには影響しない
- `readonly`を使用して変更に関するエラーを防ぎ、コード内で変更が発生する箇所を見つける
- `const`と `readonly`の違いを理解する
	- `const`は再代入を防ぎ、 `readonly`は変更を防ぐ

### 型操作とジェネリック型を使用して繰り返しを避ける
- DRY原則は、ロジックだけではなく型にも当てはまる
- 型を繰り返すのではなく、名前をつけて定義する
	- インターフェイスのフィールドを繰り返さないために `extends`を活用する
- TypeScriptが提供する型間のマッピングツール（`keyof`, `typeof`, インデックス型, マップ型など）を理解する
- ジェネリック型は型に対する関数に相当する
	- 型レベルの操作を繰り返すのではなく、ジェネリック型を使用して型をマッピングする
- 標準ライブラリで定義されているジェネリック型（`Pick`, `Partial`, `ReturnType`など）に慣れ親しむ
- DRYの適用を過剰に行わないように注意する
	- 共有するプロパティや型が本当に同じものであるかを確認する

### インデックスシグネチャよりもより正確な代替手段を優先する
- インデックスシグネチャの欠点を理解する
	- `any`と同様に型安全性を損ない、言語サービスの価値を低下させる
- 可能な限り、インデックスシグネチャよりもより正確な型を優先する
	- インターフェース、 `Map`, `Record`, マップ型、制約されたキー空間を持つインデックスシグネチャ

### 数値のインデックスシグネチャを避ける
- 配列はオブジェクトであり、そのキーは数値ではなく文字列であることを理解する
	- `number`をインデックスシグネチャとして使用するのは、バグを検出するためのTypeScriptの純粋な仕組み
- インデックスシグネチャに `number`を使用するのではなく、 `Array`, タプル, `ArrayLike`, `Iterable`型を優先する

## 3. 型推論と制御フロー解析
### 推論可能な型でコードを煩雑にしないようにする
- TypeScriptが同じ型を推論できる場合は、型アノテーションを記述しないようにする
- 理想的なTypeScriptのコードでは、関数やメソッドのシグネチャには型アノテーションを記述するが、ローカル変数には記述しない
- オブジェクトリテラルには明示的な型アノテーションを使用し、余分なプロパティチェックを有効にして、エラーが発生した場所に近い箇所で報告されるようにする
- 関数の戻り値の型は、複数の `return`文がある場合、パブリックAPIの一部である場合、特定の型を返すことを明示したい場合を除き、アノテーションしない

### 異なる型には異なる変数を使用する
- 変数の値は変わることがあるが、その型は基本的に変わらない
- 人間の読解や型チェッカーの混乱を避けるため、異なる型の値に同じ変数を再利用しないようにする

### 変数がどのようにして型を取得するかを理解する
- TypeScriptがリテラルから型を推論する際に、どのようにwideningするかを理解する
	- この動作に影響を与える方法を把握する
		- `const`, 型アノテーション, コンテキスト, ヘルパー関数, `as const`, `satisfies`など

### オブジェクトは一度に作成する
- オブジェクトは部分的にではなく、一度に構築することを優先する
- 型安全な方法でプロパティを追加するために、複数のオブジェクトやスプレッド構文を活用する
- プロパティを条件付きでオブジェクトに追加する方法を理解する

### 型の絞り込みを理解する
- TypeScriptが条件分岐やその他の制御フローに基づいて型を絞り込む仕組みを理解する
- 絞り込みを助けるために、タグ付きユニオン（判別可能なユニオン）やユーザー定義の型ガードを活用する
- TypeScriptが型の絞り込みをより容易に行えるよう、コードのリファクタリングを検討する

### エイリアスの使用は一貫性を保つ
- エイリアスの使用はTypeScriptの型の絞り込みを妨げる可能性がある
	- 変数にエイリアスを作成した場合は一貫して使用する
- 関数呼び出しがプロパティの型の絞り込みを無効にする可能性があることを理解する
	- プロパティよりもローカル変数の型の絞り込みを信用する

### 型推論におけるコンテキストの利用方法を理解する
- 型推論においてコンテキストがどのように利用されるかを理解する
- 変数を外部に切り出した際に型エラーが発生する場合は、型アノテーションを追加することを検討する
- 変数が完全に定数である場合は、 `as const`アサーションを使用する
	- ただし、これによりエラーが定義時ではなく使用時に現れる可能性があることに注意する
- 型アノテーションの必要性を減らすため、実用的であれば値をインラインで記述することを優先する

### 進化する型を理解する
- TypeScriptの型は通常、単に精緻化されるだけだが、 `null`, `undefined`, `[]`で初期化された型は進化することが許されている
	- この構造が発生する場所を認識し、自分のコードで型アノテーションの必要性を減らすために活用する
- より良いエラーチェックのために、進化する型を使うのではなく明示的な型アノテーションを提供することを検討する

### 型の流れを助けるために、関数型の構造やライブラリを活用する
- 組み込みの関数型構造や、Lodashのようなユーティリティライブラリの機能を使用し、自作の構造を避けることで型の流れを改善し可読性を高め、明示的な型アノテーションの必要性を減らす

### 型の流れを改善するために、コールバックの代わりに `async`関数を使用する
- より良い構成性と型の流れのために、コールバックよりも `Promise`を優先する
- 可能な限り、生の `Promise`よりも `async`/ `await`を優先する
	- それにより、より簡潔で分かりやすいコードになり、多くの種類のエラーを排除できる
- 関数が `Promise`を返す場合は、それを `async`と宣言する

### クラスとカリー化を使用して、新たな推論の場を構築する
- 型パラメータを複数持つ関数では、型推論は全て推論されるか、全て明示的に指定するかのどちらかになる
- 部分的な推論を得るためには、新しい推論の場を作成するためにクラスまたはカリー化を使用する
- ローカルな型エイリアスを作成したい場合は、カリー化のアプローチを優先する

## 4. 型設計
### 常に有効な状態を表す型を優先する
- 有効な状態と無効な状態の両方を表す型は混乱を招きやすく、エラーが発生しやすいコードにつながる可能性がある
- 常に有効な状態のみを表す型を優先する
	- たとえ表現が長くなったり難しくなったりしても、最終的には時間と労力の節約につながる

### 受け取るものには寛容に、生成するものは厳格に
- 入力の型は出力の型よりも広くなる傾向がある
	- パラメータの型ではオプションのプロパティやユニオン型が一般的だが、戻り値の型ではあまり使われない
- クライアントが使いにくくなるため、広すぎる戻り値の型は避ける
- パラメータと戻り値の型を再利用する場合は、戻り値の型として標準的な形式（カノニカルフォーム）を導入し、パラメータの型にはより緩い形式を採用する
- 関数のパラメータとして単にイテレーションを行う場合は、 `T[]`ではなく `Iterable<T>`を使用する

### ドキュメント内で型情報を繰り返さない
- コメントや変数名の中で型情報を繰り返さないようにする
	- 最良の場合でも型宣言と重複し、最悪の場合は矛盾した情報を生み出す可能性がある
- 変数を変更しないことをコメントで説明するのではなく、 `readonly`を使用して明示的に宣言する
- 型だけでは単位が明確でない場合、変数名に単位を含めることを検討する
	- timeMsやtemperatureCなど

### 型エイリアスに `null`や `undefined`を含めるのを避ける
- `null`や `undefined`を含む型エイリアスの定義は避ける

### `null`を型の周辺に押し出す
- ある値が `null`かどうかが、別の値が `null`かどうかと暗黙的に関連するような設計は避ける
- APIの周辺に `null`を押し出し、大きなオブジェクトを `null`または完全に非 `null`にする
	- これにより、人間の読者や型チェッカーにとってコードが明確になる
- 完全に非 `null`のクラスを作成し、すべての値が利用可能になったときに構築することを検討する

### インターフェースにユニオンを含めるよりも、インターフェースのユニオンを優先する
- 複数のプロパティがユニオン型であるインターフェースは多くの場合誤りであり、これらのプロパティ間の関係を不明瞭にする
- インターフェースのユニオンの方がより正確であり、TypeScriptによって理解されやすい
- タグ付きユニオンを使用して制御フロー解析を容易にする
	- 非常に強力にサポートされているため、このパターンはTypeScriptのコードで広く使用されている
- 複数のオプションのプロパティが、データをより正確にモデル化するためにグループ化できるかどうかを検討する

### 文字列型よりも、より正確な代替型を優先する
- 文字列型に依存したコードを避ける
	- すべての文字列が有効な可能性があるわけでない場合は、より適切な型を使用する
- 変数のドメインをより正確に表現できる場合は、 `string`よりも文字列リテラル型のユニオンを優先する
	- より厳密な型チェックが可能になり、開発体験が向上する
- 関数のパラメータがオブジェクトのプロパティであることが期待される場合、 `string`ではなく `keyof T`を優先する

### 特殊な値には明確に異なる型を使用する
- 通常の値に代入可能な特殊な値を避ける
	- これにより、TypeScriptのバグ検出能力が低下することを防ぐ
- 特殊な値として0, -1, ""を使用するのではなく、 `null`または `undefined`を優先する
- `null`や `undefined`の意味が明確ではない場合は、タグ付きユニオンを使用することを優先する

### オプショナルプロパティの使用を制限する
- オプショナルプロパティは、型チェッカーによるバグの発見を妨げ、デフォルト値を埋める際に重複や一貫性のないコードを生む可能性がある
- インターフェースにオプショナルプロパティを追加する前に検討し、必須プロパティにできないか考える
- 非正規化された入力データとコード内で使用する正規化されたデータのために、異なる型を作成することを検討する
- 組み合わせ爆発を避ける

### 同じ型のパラメータの繰り返しを避ける
- 連続する同じTypeScript型のパラメータを持つ関数を避ける
- 多くのパラメータを持つ関数は、異なる型の少数のパラメータにリファクタリングするか、単一のオブジェクトパラメータを受け取るようにする

### 差異をモデル化するのではなく、型を統一することを優先する
- 同じ型の異なるバリアントを持つことは、認知的負担を増やし、多くの変換コードを必要とする
- コード内で型のわずかな違いをモデル化するのではなく、可能であればその違いを排除し、単一の型に統一することを試みる
- 型の統一にはランタイムコードの調整が必要になる場合がある
- 型が自分の管理下にない場合は、バリエーションをモデル化する必要があるかもしれない
- 同じものを表していない型を無理に統一しない

### 不正確な型よりも、不精確な型を優先する
- 型安全性の「不気味の谷」を避ける
	- 複雑だが不正確な型は、単純でやや不精確な型よりも悪影響を及ぼすことがある
	- 型を正確にモデル化できない場合、不正確なモデルを作るのではなく、 `any`や `unknown`を使ってギャップを認識する
- 型をより精密にする際は、エラーメッセージやオートコンプリートの挙動に注意する
	- 正確さだけでなく、開発者の体験も重要である
- 型が複雑になるにつれて、それに対応するテストスイートも拡充すべきである

### 問題領域の言語を使用して型に名前を付ける
- 可能な限り、問題領域の用語を再利用して型に名前を付けることで、コードの可読性と抽象度を向上させる
	- ドメインの用語を正確に使用することを心がける
- 同じものに異なる名前を付けるのは避け、名前の違いには意味を持たせる
- 「info」や「Entity」などの曖昧な名前を避ける
	- 型の形状ではなく、その役割に基づいて名前を付ける

### 事例ベースのデータに基づいた型を避ける
- 目にしたデータに基づいて手作業で型を生成するのは避ける
	- スキーマを誤解したり、null許容性を誤る可能性がある
- 公式クライアントやコミュニティから提供される型を優先する
	- これらが存在しない場合は、スキーマからTypeScriptの型を生成する

## 5. 健全性の欠如と `any`型
### `any`型のスコープは可能な限り狭くする
- `any`を使用する際は、そのスコープを可能な限り狭くし、コード内の不要な型安全性の損失を防ぐ
- 関数の戻り値として `any`を使用しない
	- その関数を呼び出すコードの型安全性が暗黙的に失われる
- 大きなオブジェクト全体ではなく、個々のプロパティに対して `as any`を使用する

### 単純な `any`よりもより正確なバリエーションの `any`を好む
- `any`を使用する際は、あらゆるJavaScriptの値が本当に許容されるかどうかを考える
- データをより正確にモデル化できる場合は、 `any[]`や `{[id: string]: any}`,  `() => any`などの、より正確な形式の `any`を好むこと

### 安全でない型アサーションは型安全な関数内に隠す
- 時には、安全でない型アサーションや `any`型が必要または便利な場合がある
	- 必要な場合は、正しいシグネチャを持つ関数内に隠す
- 実装内の型エラーを修正するために、関数の型シグネチャを妥協しない
- 型アサーションが有効である理由を説明し、コードを十分に単体テストすること

### 型が不明な値には `any`の代わりに `unknown`を使用する
- `unknown`型は、 `any`型の型安全な代替手段
	- 値が存在することはわかっているが、その型が不明または気にしない場合に使用する
- `unknown`を使用することで、利用者に型アサーションやその他の絞り込みを強制することができる
- 誤った安心感を生む可能性があるため、戻り値専用の型パラメータは避ける
- `{}`, `object`, `unknown`の違いを理解する

### モンキーパッチには型安全なアプローチを好む
- グローバル変数やDOM上にデータを保存するのではなく、構造化されたコードを好む
- 組み込み型にデータを保存する必要がある場合は、型安全なアプローチを使用する
	- 拡張やカスタムインターフェースのアサーションなど
- 拡張のスコープの問題を理解する
	- 実行時に `undefined`の可能性がある場合は、それを考慮に入れる

### 型の健全性の罠を避ける
- 型の不健全性とは、実行時のシンボルの値が静的型と一致しない状態のことを指し、型エラーなしでクラッシュやその他の不具合を引き起こす可能性がある
- 不健全性が発生する一般的な原因として、 `any`型、型アサーション、オブジェクトや配列の参照、不正確な型定義があることに注意する
- 不健全性を避けるために、関数のパラメータを変更しないようにする
	- 変更しない場合は `readonly`としてマークする
- 子クラスが親クラスのメソッド宣言と一致していることを確認する
- オプショナルプロパティが不健全な型を引き起こす可能性があることに注意する

### 型安全性の後退を防ぐために型カバレッジを追跡すること
- noImplicitAnyを設定していても、明示的な `any`やサードパーティの型定義（@types）を通じて `any`型がコードに入り込む可能性がある
- typecoverageのようなツールを使用して、プログラムがどれだけ型付けされているかを追跡することを検討する
	- `any`の使用に関する判断を見直すきっかけとなり、時間とともに型安全性を向上させることができる

## 6. ジェネリクスと型レベルプログラミング
### ジェネリクスを型間の関数として考える
- ジェネリック型は型間の関数として考える
- `extends`を使用して型パラメータのドメインを制約する
	- 関数パラメータを制約するために型注釈を使用するのと同じ
- コードの可読性を高める型パラメータ名を選び、TSDocで説明を書く
- ジェネリック関数やクラスは、型推論を促進するジェネリック型を概念的に定義していると考える

### 不必要な型パラメータを避ける
- 必要のない関数やクラスに型パラメータを追加するのは避ける
- 型パラメータは型同士の関係を表すため、各型パラメータは少なくとも2回以上登場して関係を確立する必要がある
- 型パラメータが推論された型に現れる場合があることを忘れない
- 戻り値専用のジェネリクスは避ける
- 不要な型パラメータは、しばしば `unknown`型で代用できる

### オーバーロードシグネチャよりも条件付き型を優先する
- オーバーロードされた型シグネチャよりも条件付き型を優先する
	- 条件付き型はユニオン型に対して分配されるため、追加のオーバーロードなしでユニオン型をサポートできる
- ユニオン型のケースが現実的でない場合は、関数を異なる名前の2つ以上の関数に分けた方がわかりやすくなるかどうか検討する
- 条件付き型で宣言された関数を実装する際は、単一のオーバーロード戦略を使用することを検討する

### 条件付き型におけるユニオン型の分配を制御する方法を理解する
- ユニオン型を条件付き型に対して分配させたいかどうかを考える
- 条件を追加したり、条件を1要素のタプルでラップすることで、分配を有効化または無効化する方法を理解する
- `boolean`型や `never`型がユニオン型に対して分配される際の予期しない挙動に注意する

### テンプレートリテラル型を使用してDSLや文字列間の関係をモデル化する
- テンプレートリテラル型を使用して、文字列型の構造化されたサブセットやドメイン固有言語（DSL）をモデル化する
- テンプレートリテラル型をマップ型や条件付き型と組み合わせて、型間の微妙な関係を表現する
- 不正確な型にならないよう注意する
	- 高度な言語機能の知識を必要とせず、開発者体験を向上させる形でテンプレートリテラル型を活用することを目指す

### 型に対してテストを書く
- 型をテストする際は、特に関数型において、型の等価性と代入可能性の違いに注意する
- コールバックを使用する関数では、コールバックのパラメータに対して推論された型をテストする
	- APIの一部であれば `this`の型も忘れずにテストする
- 独自の型テストコードを作成するのは避け、標準的なツールを使用する
- DefinitelyTypedのコードではdtslintを使用する
	- 自身のコードではvitest, expect-type, またはtype-challengesの手法を使用する
	- 型の表示をテストしたい場合はeslint-plugin-expect-typeを利用する

### 型の表示方法に注意を払う
- 同じ型を表示する方法は多く存在し、その中にはより分かりやすいものもある
- TypeScriptには型の表示方法を制御するためのツールがいくつかあり、特に `Resolve`ジェネリックが有効
	- これを適切に活用することで、型の表示を明確にし、実装の詳細を隠すことができる
- 型の表示を改善するために、ジェネリック型の重要な特殊ケースに対応することを検討する
- ジェネリック型とその表示に関するテストを書き、リグレッション（予期しない挙動の変化）を防ぐ

### 末尾再帰型のジェネリック型を優先する
- 再帰的なジェネリック型は末尾再帰にすることを目指す
	- より効率的になり、型の深さ制限も緩和される
- 再帰的な型エイリアスは、累積変数（アキュムレータ）を使用することで末尾再帰に書き換えられることが多い

### 複雑な型の代替としてコード生成を検討する
- 型レベルのTypeScriptは非常に強力なツールですが、常に最適なツールとは限らない
- 複雑な型操作を行う場合、型レベルのコードを書く代わりに、コードや型を生成することを検討する
	- コード生成ツールは、通常のTypeScriptや他の言語で記述できる
- コード生成を実行し、継続的インテグレーションシステムで `git diff`を使用して、生成されたコードが最新の状態に保たれていることを確認する

## 7. TypeScriptのレシピ
### 網羅性チェックを行うために `never`型を使用する
- `never`型への代入を利用して、型のすべての可能な値が処理されていることを確認する
- 複数の分岐から値を返す関数には、戻り値の型アノテーションを追加する
	- ただし、それでも明示的な網羅性チェックを行うのが望ましい場合がある
- テンプレートリテラル型を使用して、2つ以上の型のすべての組み合わせが考慮されていることを保証することを検討する

### オブジェクトの反復方法を理解する
- 関数が受け取るオブジェクトには、想定外のキーが含まれている可能性があることに注意する
- オブジェクトのキーと値を反復処理するには、 `Object.entries`を使用する
- キーが正確にわかっている場合は、for-inループと明示的な型アサーションを使用してオブジェクトを反復処理する
- イテレーションが容易な `Map`を、オブジェクトの代替として検討する

### 値の同期を保つために `Record`型を使用する
- フェイルオープンとフェイルクローズのジレンマを理解する
- `Record`型を使用して、関連する値と型を同期させる
- インターフェースに新しいプロパティを追加する際、選択を強制するために `Record`型の仕様を検討する

### 可変長関数をモデル化するために残余引数とタプル型を使用する
- 残余引数（...rest）とタプル型を使用して、引数の型に依存する関数のシグネチャをモデル化する
- 条件付き型を使用して、1つのパラメータの型と残りのパラメータの数や型の関係をモデル化する
- タプル型の要素にラベルを付けることで、呼び出し時に意味のあるパラメータ名を得られるようにする

### `never`型のオプショナルプロパティを使用して排他的ORをモデル化する
- TypeScriptにおけるORは包含的OR（`A | B`は、A, B, または両方を含む）
- コード内で両方の可能性があることを考慮し、それを処理するか、許可しないようにする
- 排他的OR（XOR）をモデル化する際、便利な場合はタグ付きユニオンを使用する
	- それが適さない場合は、 `never`型のオプショナルプロパティを検討する

### 名前付き型を使用してノミナル型を考慮する
- ノミナル型は、値の型はその構造ではなく、明示的に指定された型によって決まる
- 構造的には同じだが意味的に異なるプリミティブ型やオブジェクト型を区別するために、ブランドを付与することを検討する
- ブランド化の様々な手法（オブジェクト型にプロパティ、文字列ベースの `enum`、プライベートフィールド、 `unique symbol`）を理解しておく

## 8. 型宣言と@types
### TypeScriptと@typesはdevDependenciesに入れる
- package.jsonにおけるdependenciesとdevDependenciesの違いを理解する
- TypeScriptはプロジェクトのdevDependenciesに入れ、システム全体にはインストールしない
- @typesの依存関係はdependenciesではなくdevDependenciesに入れる

### 型宣言に関わる3つのバージョンを理解する
- @typesの依存関係にはライブラリのバージョン、@typesのバージョン、TypeScriptのバージョンの3つが関わる
- 異なる種類のバージョン不一致の症状を認識する
- ライブラリを更新する際は、対応する@typesも更新する
- 型をバンドルするか、DefinitelyTypedに公開するかのメリットとデメリットを理解する
	- ライブラリがTypeScriptで書かれている場合は型をバンドルするのを推奨
	- TypeScriptで書かれていない場合はDefinitelyTypedに公開するのが適している

### 公開APIに含まれるすべての型をエクスポートする
- 公開メソッドに登場するあらゆる型をエクスポートすること
	- どうせユーザーはそれらの型を何らかの方法で抽出できるのだから、最初から簡単にアクセスできるようにしておくべき

### APIのコメントにはTSDocを使用する
- エクスポートされた関数、クラス、型にはJSDoc/TSDoc形式のコメントを使ってドキュメントを記述する
	- エディタが適切なタイミングでユーザーに情報を提供できるようになる
- @param, @returns, Markdownを使用してフォーマットを整える
- ドキュメント内に型情報を含めない
- 非推奨のAPIには@deprecatedを明示する

### コールバックのAPIに `this`が含まれる場合は、その型を提供すること
- `this`のバインディングの仕組みを理解する
- コールバックのAPIに `this`が含まれる場合は、その型を明示的に指定する
- 新しいAPIでは動的な `this`バインディングを避ける

### 依存関係を断つために型をミラーリングする
- 公開するnpmモジュールで推移的な型の依存関係を避ける
- 構造的型付けを活用し、不要な依存関係を切り離す
- JavaScriptユーザーに@typesへの依存を強制しない
- Web開発者にNode.jsへの依存を強制しない

### モジュール拡張を活用して型を改善する
- 宣言のマージを活用して、既存のAPIを改善したり問題のある構造を無効化する
- 戻り値を `void`やエラー文字列にすることで、メソッドを無効化し、@deprecatedと明示できる
- オーバーロードは型レベルでのみ適用されることを理解し、型と実装が乖離しないようにする

## 9. コードの記述と実行
### TypeScriptの機能よりECMAScriptの機能を優先する
- 基本的に、TypeScriptは型を削除すればJavaScriptに変換できる
	- ただし、以下の機能は例外
		- `enum`
		- パラメータプロパティ
			- `constructor(private value: string)`
		- ///で始まるトリプルスラッシュインポート
		- 実験的デコレーター
		- メンバーの可視性修飾子
			- `private`, `protected`など
- TypeScriptの役割を明確にし、将来の互換性の問題を避けるため、非標準機能の使用は控える