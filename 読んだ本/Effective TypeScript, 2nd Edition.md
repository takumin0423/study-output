## これはなに
- 重要だと感じた部分の読書メモ
- 読んだら追記する

## 1. TypeScriptについて知ろう
### TypeScriptとJavaScriptの関係を理解する
- TypeScriptはJavaScriptのスーパーセット
	- すべてのJavaScriptプログラムは構文的に有効なTypeScriptプログラムだが、すべてのTypeScriptプログラムが有効なJavaScriptプログラムであるわけではない
- TypeScriptは、JavaScriptの実行時の動作をモデル化する静的型システムを追加し、実行時に例外をスローする可能性のあるコードを検出しようとする
	- コードが型チェッカーを通過しても、実行時にエラーをスローする可能性がある
- TypeScriptは、引数の数が間違っている関数呼び出しのような、法的だが疑わしいJavaScriptの構文を禁止する
- 型注釈は、TypeScriptにプログラマーの意図を伝え、正しいコードと誤ったコードを区別するのに役立つ

### 自分が使用しているTypeScriptのオプションを把握する
- TypeScriptコンパイラには、言語の核心的な側面に影響を与えるいくつかの設定がある
	- `noImplicitAny`
	- `strictNullChecks`
- コマンドラインオプションではなく、tsconfig.jsonを使用してTypeScriptを設定する
- JavaScriptプロジェクトをTypeScriptに移行している場合を除き、 `noImplicitAny`をオンにする
- `strictNullChecks`を使用して、「undefined is not an object」型の実行時エラーを防ぐ
- TypeScriptが提供する最も徹底的なチェックを受けるために、 `strict`を有効にすることを目指す

### コード生成は型から独立していることを理解する
- コード生成は型システムとは独立している
	- TypeScriptの型はコードの実行時の動作に影響を与えることはない
- 型エラーがあるプログラムでもコードを生成（コンパイル）することができる
- TypeScriptの型は実行時には利用できない
	- 実行時に型をクエリするには、型を再構築する方法が必要
		- タグ付きユニオン
		- プロパティチェック
- クラスのような構文は、TypeScriptの型と実行時に利用できる値の両方を導入する
- TypeScriptの型はコンパイルの一部として削除されるため、実行時のパフォーマンスに影響を与えることはない

### 構造的型付けに慣れる
- JavaScriptはダックタイピングであり、TypeScriptはこれをモデル化するために構造的型付けを使用する
	- インターフェースに割り当て可能な値は、型宣言に明示的にリストされているプロパティ以上のものを持つ場合がある
- クラスも構造的型付けのルールに従う
	- 予期しているクラスのインスタンスが得られない可能性がある
- 構造的型付けを使用して、ユニットテストを容易にすることができる

### any型の使用を制限する
- TypeScriptのany型は、型チェックのほとんどを無効にできる
- any型は型の安全性を排除し、契約を破り、開発者の体験を損ない、リファクタリングの際にエラーが発生させやすくし、型設計を隠し、型システムへの信頼を損ねる
- できるだけanyの使用は避ける

## 2. TypeScriptの型システム
### エディタを使用して型システムを調査し、探求する
- TypeScriptの言語サービスを活用するために、それらをサポートするエディタを使用する
- エディタを使って、型システムがどのように機能し、TypeScriptがどのように型を推論するかについての直感を養う
- TypeScriptのリファクタリングツールに慣れ親しむ
	- シンボルやファイルの名前変更など
- 型宣言ファイルにジャンプし、どのように挙動をモデル化しているかを確認する方法を把握する

### 型を値の集合として考える
- 型を値の集合（型のドメイン）として考える
	- これらの集合は有限であることもあれば（boolean型やリテラル型）、無限であることもある（number型やstring型）
- TypeScriptの型は厳密な階層ではなく、交差する集合（ベン図）を形成する
	- 2つの型は、互いにサブタイプでなくても重なることがある
- オブジェクトは型宣言に記載されていない追加のプロパティを持っていても、型に属することがある
- 型操作は集合のドメインに適用される
	- `A | B`のドメインは、AとBのドメインの和集合
- 「extends」「assignable to」「subtype to」を「subset of」の同義語として考える

### 記号が型空間にあるのか値空間にあるのかを判別する方法を知る
- TypeScriptの式を読んでいるとき、型空間と値空間のどちらにいるかを見分ける方法を知っておく
	- TypeScriptプレイグラウンド
- すべての値には静的型があるが、これは型空間でのみアクセスできる
	- 型やインターフェースのような型空間の構造は消去され、値空間ではアクセスできない
- クラスや列挙型のような一部の構造は、型と値の両方を導入する
- `typeof`, `this`, その他多くの演算子やキーワードは、型空間と値空間で異なる意味を持つ

### 型アサーションより型注釈を優先する
- 型注釈（`: Type`）を型アサーション（`as Type`）よりも優先して使用する
- アロー関数の戻り値の型をどのようにアノテートするかを知っておく
- 型アサーションや非nullアサーションは、TypeScriptが知らない型について何かを知っている場合にのみ使用する
- 型アサーションを使用する場合は、それが有効である理由を説明するコメントを残す

### オブジェクトラッパー型（String, Number, Boolean, Symbol, BigInt）を避ける
- TypeScriptのオブジェクトラッパー型は使用を避け、プリミティブ型を使用する
- オブジェクトラッパー型がプリミティブ型にメソッドを提供する方法を理解する
	- オブジェクトラッパー型を直接インスタンス化したり使用するのは避けるべきだが、SymbolとBigIntは例外

### 余分なプロパティチェックと型チェックを区別する
- オブジェクトリテラルを既知の型の変数に代入したり、関数に引数として渡すと余分なプロパティチェックが行われる
	- 余分なプロパティチェックはエラーを見つけるための効果的な方法だが、TypeScriptの型チェッカーが行う通常の構造的な代入可能性チェックとは異なる
		- これらのプロセスを混同すると、代入可能性のメンタルモデルを構築するのが難しくなるので注意
		- TypeScriptの構造的型付けは「閉じていない」
- 余分なプロパティチェックの限界を理解する
	- 中間変数を導入すると、これらのチェックが削除される
- 「弱い型」はオプショナルなプロパティのみを持つオブジェクト型
	- これらの型の場合、代入可能性チェックには少なくとも1つの一致するプロパティが必要

### 可能な場合は関数式全体に型を適用する
- パラメーターや戻り値の型に対してではなく、関数式全体に型注釈を適用することを検討する
- 同じ型シグネチャを繰り返し書いている場合は、関数型を抽出するか既存の型を探す
- ライブラリ作成者であれば、一般的なコールバックに対して型を提供する
- 他の関数のシグネチャに一致させるためには、 `typeof fn`を使用したり、戻り値の型を変更する必要がある場合は `Parameters`やrestパラメーターを使用する

### typeとinterfaceの違いを理解する
- `type`と `interface`の違いと相違点を理解する
- 両方の構文を使って同じ型を記述する方法を知っておく
- `interface`の宣言マージや、型のインライン化に注意する
- 確立されたスタイルがないプロジェクトでは、オブジェクト型には `interface`を優先する

### 変更に関連するエラーを回避するために `readonly`を使用する
- 関数がパラメータを変更しない場合は、配列には `readonly`を、オブジェクト型には `Readonly`を宣言する
	- 関数の契約が明確になり、実装での意図しない変更を防ぐことができる
- `readonly`と `Readonly`が浅いものであり、 `Readonly`はプロパティのみに影響し、メソッドには影響しない
- `readonly`を使用して変更に関するエラーを防ぎ、コード内で変更が発生する箇所を見つける
- `const`と `readonly`の違いを理解する
	- `const`は再代入を防ぎ、 `readonly`は変更を防ぐ

### 型操作とジェネリック型を使用して繰り返しを避ける
- DRY原則は、ロジックだけではなく型にも当てはまる
- 型を繰り返すのではなく、名前をつけて定義する
	- インターフェイスのフィールドを繰り返さないために `extends`を活用する
- TypeScriptが提供する型間のマッピングツール（`keyof`, `typeof`, インデックス型, マップ型など）を理解する
- ジェネリック型は型に対する関数に相当する
	- 型レベルの操作を繰り返すのではなく、ジェネリック型を使用して型をマッピングする
- 標準ライブラリで定義されているジェネリック型（`Pick`, `Partial`, `ReturnType`など）に慣れ親しむ
- DRYの適用を過剰に行わないように注意する
	- 共有するプロパティや型が本当に同じものであるかを確認する