## これはなに

- 重要だと感じた部分の読書メモ
- 読んだら追記する

## 1. TypeScript について知ろう

### TypeScript と JavaScript の関係を理解する

- すべての JavaScript プログラムは TypeScript プログラムだが、すべての TypeScript プログラムが JavaScript プログラムというわけではない
  - TypeScript が型を指定するために構文を追加しているから
- TypeScript の型システムの目標のひとつは、コードを実行することなく、実行時に例外をスローするコードを検出すること
  - TypeScript が静的型システムであると説明される場合、この能力を指している
- TypeScript の型システムの指針となる原則は、JavaScript の実行時動作をモデル化すること
  - ただ、JavaScript として奇妙な使用法の場合、型チェッカーは開発者の意図によるものよりもエラーの可能性が高いと判断し、例外をスローしなくてもエラーを警告する
- 型チェックを行ったとしても、実行時にエラーが発生する可能性はある
  - 範囲外の配列アクセスや任意の型を使用する場合など
  - 根本的な原因は、TypeScript が値の型（静的型）と実行時の実際の型を正しく理解できなかったことにある
    - 静的型の正確性を保証できる型システムは「健全である」と言われるが、TypeScript の型システムは「健全である」とは言えない
      - 健全であるように意図されたこともない
- 型システムの健全性を重要視するのであれば、Reason, PureScript, Dart など他の言語の採用を検討した方が良い
  - TypeScript よりも実行時の安全性をより保証するが、代償としてコードが正しいことを型チェッカーに納得させるのにより多くの作業が必要となる
  - どれも JavaScript のスーパーセットではないため、移行がより複雑になる
- 型注釈は、TypeScript に開発者の意図を伝え、正しいコードと正しくないコードを区別するのに役立つ

### 自分が使用している TypeScript のオプションを把握する

- noImplicitAny は、変数の型を決定できない場合に TypeScript が実行する処理を制御する
  - オンにすることで、TypeScript が型に関する問題を検出できるようになる
  - 可能な限りオンにするべき
- strictNullChecks は、あらゆる型において null と undefined が許容される値であるかどうかを制御する
  - 新しいプロジェクト、TypeScript の使用経験がある場合はなるべくオンにするべき
  - JavaScript を TypeScript に移行している場合はオフにするのもあり
    - オフにする場合は、`undefined is not an object`などの実行時エラーが発生しないように注意する
- 他のオプションは noImplicitAny や strictNullChecks に比べると些細なもの
  - ただ有用なものもあるので、認識しておくべき
- TypeScript が提供する最も徹底したチェックを行うには strict を有効にする

### コード生成は型から独立していることを理解する

- tsc（TypeScript コンパイラ）は以下の 2 つのことを行う
  - 次世代の JavaScript/TypeScript を、ブラウザやその他のランタイムで動作する旧バージョンの JavaScript に変換する（トランスパイル）
  - コードの型エラーをチェックする
- コード内の型は TypeScript が出力する JavaScript に影響を与えることができない
- TypeScript の型を実行時に確認することはできない
  - JavaScript へのコンパイルの一部として、インターフェイス、型、型注釈をすべてコードから削除する
- 実行時に型情報を取得するための方法として、kind のようなプロパティを型に持たせ、それを用いて判別するタグ付き/判別ユニオン（tagged/discriminated unions）が TypeScript では広く使用されている
- class キーワードのように型（実行時に取得できない）と値（実行時に利用できる）の両方を導入する構文を使うこともできる
- タイプエラーのあるコードは出力を生成できる
  - コードの出力は型チェックとは独立しているため、型エラーのあるコードでも出力が生成される可能性がある
- TypeScript のエラーはすべて、C や Java のような「型チェックと出力が密接に関連している」言語の警告に似ている
  - エラー自体は問題を示している可能性が高く調査する価値があるが、ビルドを停止させることはない
- TypeScript でよく聞く「コンパイルができない」という表現は不適切で、正しくは「コードにエラーがある」、もしくは「型チェックが出来ない」という方が適切
  - TypeScript が有効な JavaScript である限り、TypeScript コンパイラは出力を生成するから
- エラーがある場合でもコードが生成されることで、問題を修正する前にアプリケーションの他の部分をテストすることができる
- コードをコミットする際には、エラーをゼロにすることを目指すべき
  - 予期されるエラーと予期されないエラーを覚えておく必要が出てきてしまうから
- 型操作は実行時の値に影響を与えることはできない
  - `as number`は型アサーションであり、キャストではない
- 実行時の型は宣言された型と同一であるとは限らない
  - 関数がネットワーク呼び出しなどから得られる値で呼び出される場合、予期しない型や値を含む可能性がある
  - 実行時の型が宣言された型と一致しない場合、非常に混乱を招く可能性がある
  - 不健全な型は可能な限り避けるべきだが、宣言された型とは異なる型を値が実行時に持つ可能性があることは理解しておく必要がある
- TypeScript の型に基づいて関数をオーバーロードすることはできない
  - C++のような言語では、パラメータが異なる複数のバージョンの関数を定義できる
    - 関数のオーバーロードと呼ばれる
    - TypeScript ではコード実行時の挙動がその型情報に依存しないため、こういった構造は使用できない
  - TypeScript は関数のオーバーロード機能を提供しているが、完全に型レベルで動作する
    - 関数に複数の型シグネチャを指定することはできるが、実装は 1 つだけに限られる
- TypeScript の型は実行時のパフォーマンスに影響を与えない
  - 型や型操作は JavaScript を生成する際に消去されるため、実行時のパフォーマンスに影響を与えることはない

### 構造的型付けに慣れる

- 構造的型付けを十分に理解することでエラーと非エラーを理解し、より堅牢なコードを書くのに役立つ
- JavaScript はダックタイピングであり、TypeScript は構造的型付けを使用している
  - インターフェースに割り当て可能な値には、型宣言に明示的に列挙されたもの以外のプロパティが含まれる可能性がある
- クラスも構造的型付けの規則に従うことに注意する
  - 期待通りのクラスインスタンスが得られない可能性がある
- ユニットテストを容易にするために構造的型付けを使用できる

### any 型の使用を制限する

- any 型を使用すると、TypeScript を使用する利点の多くが失われる
  - 型安全性が保証されない
  - 型による契約を破る
  - 型による補完やドキュメントの恩恵を受けられなくなる
- any 型を使用すると、型設計が暗黙的になりその設計がどのようなものであるかが分からなくなってしまう
- any 型は出来る限り使わない！

## 2. TypeScript の型システム

### エディタを使用して型システムを調査し、探求する

- 型やメソッドから、その定義が行われている型宣言ファイルにジャンプし、動作モデルを確認することができる

### 型を値の集合として考える

- 変数には型があり、これは想定される値の集合体であると考えるのが最適
  - この集合は型のドメインと捉えられる
- 最小の集合は空の集合であり、値は含まれない
  - TypeScript の never 型に対応する
    - never 型の変数には値を代入できない
- 他の言語でユニット型と呼ばれるような単一の値を含むものは、TypeScript のリテラル型に対応する
- ユニオン型のドメインは、その構成要素のドメインのユニオン（和集合）
- 型チェッカーが実行していることの多くは、ある集合が別の集合のサブセットであるかどうかをテストすること
- 型を値の集合として考えることで、それらに対する操作について論理的に考えることができる
- 一般的なルールとして、ユニオン型に属する値はそれを構成する各型のプロパティの和集合を含む
  - ユニオン型の値に確実に存在すると判断できるキーは存在しないため、ユニオン型に対する `keyof`は空集合（never 型）でなければならない
- 型を値の集合として考えると、 `extends`は「代入可能」と同じように「部分集合」として読むことができる
  - `extends`は通常、インターフェースにフィールドを追加するために使用されますが、基底型の値の部分集合に一致するものならサブタイプはかまわない
    - 基底型の型の部分集合である限り、TypeScript はそれを許可する
    - 部分集合ではなく基底型の型を拡張しようとした場合、エラーになる
- 基底型とサブタイプの関係は、型を値の集合として考えるのであれば階層ではなくベン図として捉えるた方がわかりやすい
  - ベン図を用いると、 `extends`を使わずにインターフェースを書き直しても部分集合/サブタイプ/割り当て可能性の関係が変わらないことが明らか
  - オブジェクト型の場合はどちらの解釈でも成立するが、リテラル型やユニオン型を考えると集合として解釈した方が直感的に理解しやすい
- `extends`キーワードはジェネリック型の制約としても使用されることがあり、この文脈でも部分集合を意味する

```ts
function getKey<K extends string>(val: any, key: K) {}
```

- 上記のようなコードの場合、 `extends`を集合の観点で考えると、ドメイン（K）が string の部分集合である型ならどれでも適合すると考えられる
  - 文字列リテラル型、文字列リテラル型のユニオン型、テンプレートリテラル型、string 自体が含まれる
- 集合の解釈は、関係が必ずしも厳密な階層構造ではない型を扱うときにもより理にかなっている
  - `string | number`と `string | Date`があった場合、交差部分として string が含まれるが、どちらも他方のサブタイプではない
  - ユニオン型は階層構造に当てはまらない場合があるが、値の集合として考えることができる
- 型を集合として考えることは、配列とタプルの関係を明確にするのにも役立つ
- 型を値の集合として考えるのであれば、同じ値の集合を持つ 2 つの型は同じ型だということになる
  - 2 つの型が意味的に異なり、たまたま同じドメインを持つのでない限り、同じ型を 2 回定義する理由はない
  - 同じドメインを持っていても、片方が不変でもう片方がそうではない時には違いが生まれる
    - 一般的に、型チェッカーは不変な値を扱う時により効果的に機能する
- unknown 型のドメイン（値）は JavaScript のすべての値であり、すべての型は unknown 型に割り当て可能
  - この型が型階層の最上階にあるため、トップ型と呼ばれる
- すべての値の集合が TypeScript の型に対応するわけではない
  - すべての値が TypeScript の型として表現できるわけではない、という意味
- オブジェクトが型宣言で言及されていない追加プロパティを持っていても、その型に属することがあることを覚えておく
- 型の操作は集合のドメインに適用される
  - A | B のドメインは、A と B のドメインの和集合
- 「extends」, 「assignable to」, 「subtype of」を「部分集合」と同義として考える

### 記号が型空間にあるのか値空間にあるのかを判別する方法を知る

- TypeScript の記号は次の 2 つの空間のいずれかに存在する
  - 型空間
  - 値空間
- 同じ名前がどの空間に属しているかによって異なるものを指す場合があるため、混乱を招くことがある

```ts
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({ radius, height });
```

- `interface Cylinder`は型空間に記号を導入する
- `const Cylinder`は同じ名前で値空間に記号を導入する
- 上記の 2 つは互いに無関係で、 `Cylinder`と書いた場合、文脈によってそれが型を指しているのか値を指しているのかが変わる
  - `instanceof Cylinder`は型ではなく関数を指す（値に対して動作する）
  - `type`や `interface`の後に続く記号は型空間に属する
  - `const`や `let`宣言で導入された記号は値空間に属する
- 2 つの空間についての直感を養う最善の方法は、TypeScript Playground を使うこと
  - TypeScript ソースコードから生成された JavaScript を確認できる
    - 型はコンパイル中に消去されるため、記号が消える場合、それは型空間に属していたことを意味する
- TypeScript の文は、型空間と値空間を交互に切り替えることがある
  - 型宣言（`:`）や型アサーション（`as`）の後の記号は型空間に属するが、代入（`=`）の後のすべては値空間に属する
  - 関数分は、型空間と値空間の間を繰り返し交互に切り替えることがある
- クラスと列挙型（`enum`）の構造は、型と値の両方を導入する
- 型コンテキストと値コンテキストで異なる意味を持つ演算子やキーワードは多くある
  - `typeof`
    - 型コンテキストでは値を受け取り、その値の TypeScript の型を返す
      - より大きな型の一部として使用したり、 `type`文を使って名前を付けたりできる
    - 値コンテキストでは JavaScript ランタイムの `typeof`演算子として機能し、記号のランタイム型を含む文字列を返す
      - これは TypeScript の型と同じではない
  - `this`
    - 値空間では、JavaScript の `this`キーワードを指す
    - 型空間では、TypeScript の this 型（いわゆるポリモーフィック this）を指す
      - サブクラスを伴うメソッドチェーンの実装に役立つ
  - `&`と `|`
    - 値空間では、それぞれビット演算の AND と OR を表す
    - 型空間では、それぞれインターセクション型とユニオン型を表す
  - `const`と `as const`
    - 値空間では、 `const`は新しい変数を導入する
    - 型空間では、 `as const`はリテラルまたはリテラル式の推論型を変更する
  - `extends`
    - 値空間ではサブクラスを定義する
    - 型空間ではサブタイプを定義、またはジェネリック型の制約を設定する
  - `in`
    - 値空間では `for`ループで使用される
    - 型空間では Mapped Types で使用される
  - `!`
    - 値空間では、JavaScript の論理否定演算子を表す
    - 型空間では、非 null 型アサーションを表す

### 型アサーションより型注釈を優先する

- 型注釈は、値がインターフェースに準拠していることを確認し、準拠していない場合エラーを警告する
- 型アサーションは、上記のエラーを抑制してしまう
  - 「自分の方が型チェッカーよりも正しい」と伝えることで、エラーを無視するようなもの
- 特定の理由がない限り、型アサーションではなく型注釈を使用するべき
- 型アサーションはいつ使うべきか？
  - TypeScript が持たない情報を持っている場合、型アサーションを使用するのは理にかなっている
    - ブラウザで作業している場合、TypeScript よりも DOM 要素の型をより正確に知っていることがある
  - 変数の型が null を含んでいるが、文脈からそれが不可能だと分かっている場合
    - この型アサーションは非常に一般的であるため、特別な構文（`!`）が用意されており、非 null アサーションとして知られている
      - `as`を使用するよりも改善されていて、型の非 null の部分がそのまま保持される
      - `!`を使用する際は、他の型アサーションと同じように注意を払うべき
        - コンパイル時に削除されるため、型チェッカーが持たない情報を持っており、値が null でないことを保証できる場合にのみ使うべき
        - 保証できない場合は、条件分岐を使用して null の場合を確認すべき
- 型アサーションを使用する際は、それが有効である理由をコメントに含めるべき
  - 人間の読者に欠けている情報を提供し、アサーションが依然として正当化されているかを評価する助けとなる
- オブジェクトのプロパティやメソッドにアクセスする際に、それが null の可能性がある場合はオプショナルチェイン演算子（`?.`）を使うと便利
  - JavaScript の構文で、実行時に null（または undefined）かどうかを確認してから式の評価を続行する
  - 乱用しすぎないように注意
    - null と undefined を無視するべきでないところで使わないように
- 型アサーションには限界があり、任意の型同士を変換することはできない
  - 一般的なルールとして、型アサーションを使用して型 A を型 B に変換するためには、両者が「互いに比較可能」である必要がある
    - 集合の用語を使うと、A と B が「空でない共通部分」を持つ必要がある
  - 回避策として unknown 型を使用する方法がある
    - すべての型は unknown のサブタイプであるため、unknown を含む型アサーションは常に有効
    - 任意の型間で変換が可能になるが、少なくとも「疑わしい操作を行っている」ことを明示的に示すことになる
- 型アサーションは「キャスト」と呼ばれることもあるが、誤解を招きやすいので避けるのが賢明
  - C 言語のような言語では、キャストは実行時に値を変換することができる（`int`を`float`に変換など）
  - 型アサーションは型レベルの構造であり、実行時に削除されるので、値を変更するのではなく値に関してすでに真であることを「主張」するだけ
- `as const`は型アサーションのように見えるが、実際には「const コンテキスト」と呼ばれるもの
  - `as T`は注意深く扱うべきだが、 `as const`は型をより正確にし、完全に安全

### オブジェクトラッパー型（String, Number, Boolean, Symbol, BigInt）を避ける

- オブジェクトに加えて、JavaScript には 7 種類のプリミティブ型がある
  - string
  - number
  - boolean
  - null
  - undefined
  - symbol: ES2015 で追加
  - bigint: ES2020 で追加
- プリミティブは変更不可能であり、メソッドを持たない点でオブジェクトと区別される

## 3. 型推論と制御フロー解析

- sample

## 4. タイプデザイン

- sample

## 5. 不健全性とあらゆるタイプ

- sample

## 6. ジェネリクスと型レベルプログラミング

- sample

## 7. TypeScript のレシピ

- sample

## 8. 型宣言と@types

- sample

## 9. コードの記述と実行

- sample

## 10. 近代化と移行

- sample
