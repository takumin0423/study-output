## これはなに
- 重要だと感じた部分の読書メモ
- 読んだら追記する

## 1. TypeScriptについて知ろう
### TypeScriptとJavaScriptの関係を理解する
- すべてのJavaScriptプログラムはTypeScriptプログラムだが、すべてのTypeScriptプログラムがJavaScriptプログラムというわけではない
	- TypeScriptが型を指定するために構文を追加しているから
- TypeScriptの型システムの目標のひとつは、コードを実行することなく、実行時に例外をスローするコードを検出すること
	- TypeScriptが静的型システムであると説明される場合、この能力を指している
- TypeScriptの型システムの指針となる原則は、JavaScriptの実行時動作をモデル化すること
	- ただ、JavaScriptとして奇妙な使用法の場合、型チェッカーは開発者の意図によるものよりもエラーの可能性が高いと判断し、例外をスローしなくてもエラーを警告する
- 型チェックを行ったとしても、実行時にエラーが発生する可能性はある
	- 範囲外の配列アクセスや任意の型を使用する場合など
	- 根本的な原因は、TypeScriptが値の型（静的型）と実行時の実際の型を正しく理解できなかったことにある
		- 静的型の正確性を保証できる型システムは「健全である」と言われるが、TypeScriptの型システムは「健全である」とは言えない
			- 健全であるように意図されたこともない
- 型システムの健全性を重要視するのであれば、Reason, PureScript, Dartなど他の言語の採用を検討した方が良い
	- TypeScriptよりも実行時の安全性をより保証するが、代償としてコードが正しいことを型チェッカーに納得させるのにより多くの作業が必要となる
	- どれもJavaScriptのスーパーセットではないため、移行がより複雑になる
- 型注釈は、TypeScriptに開発者の意図を伝え、正しいコードと正しくないコードを区別するのに役立つ

### 自分が使用しているTypeScriptのオプションを把握する
- noImplicitAnyは、変数の型を決定できない場合にTypeScriptが実行する処理を制御する
	- オンにすることで、TypeScriptが型に関する問題を検出できるようになる
	- 可能な限りオンにするべき
- strictNullChecksは、あらゆる型においてnullとundefinedが許容される値であるかどうかを制御する
	- 新しいプロジェクト、TypeScriptの使用経験がある場合はなるべくオンにするべき
	- JavaScriptをTypeScriptに移行している場合はオフにするのもあり
		- オフにする場合は、`undefined is not an object`などの実行時エラーが発生しないように注意する
- 他のオプションはnoImplicitAnyやstrictNullChecksに比べると些細なもの
	- ただ有用なものもあるので、認識しておくべき
- TypeScriptが提供する最も徹底したチェックを行うにはstrictを有効にする

### コード生成は型から独立していることを理解する
- tsc（TypeScriptコンパイラ）は以下の2つのことを行う
	- 次世代のJavaScript/TypeScriptを、ブラウザやその他のランタイムで動作する旧バージョンのJavaScriptに変換する（トランスパイル）
	- コードの型エラーをチェックする
- コード内の型はTypeScriptが出力するJavaScriptに影響を与えることができない
- TypeScriptの型を実行時に確認することはできない
	- JavaScriptへのコンパイルの一部として、インターフェイス、型、型注釈をすべてコードから削除する
- 実行時に型情報を取得するための方法として、kindのようなプロパティを型に持たせ、それを用いて判別するタグ付き/判別ユニオン（tagged/discriminated unions）がTypeScriptでは広く使用されている
- classキーワードのように型（実行時に取得できない）と値（実行時に利用できる）の両方を導入する構文を使うこともできる
- タイプエラーのあるコードは出力を生成できる
	- コードの出力は型チェックとは独立しているため、型エラーのあるコードでも出力が生成される可能性がある
- TypeScriptのエラーはすべて、CやJavaのような「型チェックと出力が密接に関連している」言語の警告に似ている
	- エラー自体は問題を示している可能性が高く調査する価値があるが、ビルドを停止させることはない
- TypeScriptでよく聞く「コンパイルができない」という表現は不適切で、正しくは「コードにエラーがある」、もしくは「型チェックが出来ない」という方が適切
	- TypeScriptが有効なJavaScriptである限り、TypeScriptコンパイラは出力を生成するから
- エラーがある場合でもコードが生成されることで、問題を修正する前にアプリケーションの他の部分をテストすることができる
- コードをコミットする際には、エラーをゼロにすることを目指すべき
	- 予期されるエラーと予期されないエラーを覚えておく必要が出てきてしまうから
- 型操作は実行時の値に影響を与えることはできない
	- `as number`は型アサーションであり、キャストではない
- 実行時の型は宣言された型と同一であるとは限らない
	- 関数がネットワーク呼び出しなどから得られる値で呼び出される場合、予期しない型や値を含む可能性がある
	- 実行時の型が宣言された型と一致しない場合、非常に混乱を招く可能性がある
	- 不健全な型は可能な限り避けるべきだが、宣言された型とは異なる型を値が実行時に持つ可能性があることは理解しておく必要がある
- TypeScriptの型に基づいて関数をオーバーロードすることはできない
	- C++のような言語では、パラメータが異なる複数のバージョンの関数を定義できる
		- 関数のオーバーロードと呼ばれる
		- TypeScriptではコード実行時の挙動がその型情報に依存しないため、こういった構造は使用できない
	- TypeScriptは関数のオーバーロード機能を提供しているが、完全に型レベルで動作する
		- 関数に複数の型シグネチャを指定することはできるが、実装は1つだけに限られる
- TypeScriptの型は実行時のパフォーマンスに影響を与えない
	- 型や型操作はJavaScriptを生成する際に消去されるため、実行時のパフォーマンスに影響を与えることはない

### 構造的型付けに慣れる
- 構造的型付けを十分に理解することでエラーと非エラーを理解し、より堅牢なコードを書くのに役立つ
- JavaScriptはダックタイピングであり、TypeScriptは構造的型付けを使用している
	- インターフェースに割り当て可能な値には、型宣言に明示的に列挙されたもの以外のプロパティが含まれる可能性がある
- クラスも構造的型付けの規則に従うことに注意する
	- 期待通りのクラスインスタンスが得られない可能性がある
- ユニットテストを容易にするために構造的型付けを使用できる

### any型の使用を制限する
- any型を使用すると、TypeScriptを使用する利点の多くが失われる
	- 型安全性が保証されない
	- 型による契約を破る
	- 型による補完やドキュメントの恩恵を受けられなくなる
- any型を使用すると、型設計が暗黙的になりその設計がどのようなものであるかが分からなくなってしまう
- any型は出来る限り使わない！

## 2. TypeScriptの型システム
### エディタを使用して型システムを調査し、探求する
- 型やメソッドから、その定義が行われている型宣言ファイルにジャンプし、動作モデルを確認することができる

### 型を値の集合として考える
- 変数には型があり、これは想定される値の集合体であると考えるのが最適
	- この集合は型のドメインと捉えられる
- 最小の集合は空の集合であり、値は含まれない
	- TypeScriptのnever型に対応する
		- never型の変数には値を代入できない
- 他の言語でユニット型と呼ばれるような単一の値を含むものは、TypeScriptのリテラル型に対応する
- ユニオン型のドメインは、その構成要素のドメインのユニオン（和集合）
- 型チェッカーが実行していることの多くは、ある集合が別の集合のサブセットであるかどうかをテストすること
- 型を値の集合として考えることで、それらに対する操作について論理的に考えることができる
- 一般的なルールとして、ユニオン型に属する値はそれを構成する各型のプロパティの和集合を含む
	- ユニオン型の値に確実に存在すると判断できるキーは存在しないため、ユニオン型に対する `keyof`は空集合（never型）でなければならない
- 型を値の集合として考えると、 `extends`は「代入可能」と同じように「部分集合」として読むことができる
	- `extends`は通常、インターフェースにフィールドを追加するために使用されますが、基底型の値の部分集合に一致するものならサブタイプはかまわない
		- 基底型の型の部分集合である限り、TypeScriptはそれを許可する
		- 部分集合ではなく基底型の型を拡張しようとした場合、エラーになる
- 基底型とサブタイプの関係は、型を値の集合として考えるのであれば階層ではなくベン図として捉えるた方がわかりやすい
	- ベン図を用いると、 `extends`を使わずにインターフェースを書き直しても部分集合/サブタイプ/割り当て可能性の関係が変わらないことが明らか
	- オブジェクト型の場合はどちらの解釈でも成立するが、リテラル型やユニオン型を考えると集合として解釈した方が直感的に理解しやすい
- `extends`キーワードはジェネリック型の制約としても使用されることがあり、この文脈でも部分集合を意味する
```ts
function getKey<K extends string>(val: any, key: K) {}
```
- 上記のようなコードの場合、 `extends`を集合の観点で考えると、ドメイン（K）がstringの部分集合である型ならどれでも適合すると考えられる
	- 文字列リテラル型、文字列リテラル型のユニオン型、テンプレートリテラル型、string自体が含まれる
- 集合の解釈は、関係が必ずしも厳密な階層構造ではない型を扱うときにもより理にかなっている
	- `string | number`と `string | Date`があった場合、交差部分としてstringが含まれるが、どちらも他方のサブタイプではない
	- ユニオン型は階層構造に当てはまらない場合があるが、値の集合として考えることができる
- 型を集合として考えることは、配列とタプルの関係を明確にするのにも役立つ
- 型を値の集合として考えるのであれば、同じ値の集合を持つ2つの型は同じ型だということになる
	- 2つの型が意味的に異なり、たまたま同じドメインを持つのでない限り、同じ型を2回定義する理由はない
	- 同じドメインを持っていても、片方が不変でもう片方がそうではない時には違いが生まれる
		- 一般的に、型チェッカーは不変な値を扱う時により効果的に機能する
- unknown型のドメイン（値）はJavaScriptのすべての値であり、すべての型はunknown型に割り当て可能
	- この型が型階層の最上階にあるため、トップ型と呼ばれる
- すべての値の集合がTypeScriptの型に対応するわけではない
	- すべての値がTypeScriptの型として表現できるわけではない、という意味

## 3. 型推論と制御フロー解析
- sample

## 4. タイプデザイン
- sample

## 5. 不健全性とあらゆるタイプ
- sample

## 6. ジェネリクスと型レベルプログラミング
- sample

## 7. TypeScriptのレシピ
- sample

## 8. 型宣言と@types
- sample

## 9. コードの記述と実行
- sample

## 10. 近代化と移行
- sample