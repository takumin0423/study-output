## これはなに
- 重要だと感じた部分の読書メモ
- 読んだら追記する

## 1. TypeScriptについて知ろう
### TypeScriptとJavaScriptの関係を理解する
- すべてのJavaScriptプログラムはTypeScriptプログラムだが、すべてのTypeScriptプログラムがJavaScriptプログラムというわけではない
	- TypeScriptが型を指定するために構文を追加しているから
- TypeScriptの型システムの目標のひとつは、コードを実行することなく、実行時に例外をスローするコードを検出すること
	- TypeScriptが静的型システムであると説明される場合、この能力を指している
- TypeScriptの型システムの指針となる原則は、JavaScriptの実行時動作をモデル化すること
	- ただ、JavaScriptとして奇妙な使用法の場合、型チェッカーは開発者の意図によるものよりもエラーの可能性が高いと判断し、例外をスローしなくてもエラーを警告する
- 型チェックを行ったとしても、実行時にエラーが発生する可能性はある
	- 範囲外の配列アクセスや任意の型を使用する場合など
	- 根本的な原因は、TypeScriptが値の型（静的型）と実行時の実際の型を正しく理解できなかったことにある
		- 静的型の正確性を保証できる型システムは「健全である」と言われるが、TypeScriptの型システムは「健全である」とは言えない
			- 健全であるように意図されたこともない
- 型システムの健全性を重要視するのであれば、Reason, PureScript, Dartなど他の言語の採用を検討した方が良い
	- TypeScriptよりも実行時の安全性をより保証するが、代償としてコードが正しいことを型チェッカーに納得させるのにより多くの作業が必要となる
	- どれもJavaScriptのスーパーセットではないため、移行がより複雑になる
- 型注釈は、TypeScriptに開発者の意図を伝え、正しいコードと正しくないコードを区別するのに役立つ

### 自分が使用しているTypeScriptのオプションを把握する
- noImplicitAnyは、変数の型を決定できない場合にTypeScriptが実行する処理を制御する
	- オンにすることで、TypeScriptが型に関する問題を検出できるようになる
	- 可能な限りオンにするべき
- strictNullChecksは、あらゆる型においてnullとundefinedが許容される値であるかどうかを制御する
	- 新しいプロジェクト、TypeScriptの使用経験がある場合はなるべくオンにするべき
	- JavaScriptをTypeScriptに移行している場合はオフにするのもあり
		- オフにする場合は、`undefined is not an object`などの実行時エラーが発生しないように注意する
- 他のオプションはnoImplicitAnyやstrictNullChecksに比べると些細なもの
	- ただ有用なものもあるので、認識しておくべき
- TypeScriptが提供する最も徹底したチェックを行うにはstrictを有効にする

### コード生成は型から独立していることを理解する
- tsc（TypeScriptコンパイラ）は以下の2つのことを行う
	- 次世代のJavaScript/TypeScriptを、ブラウザやその他のランタイムで動作する旧バージョンのJavaScriptに変換する（トランスパイル）
	- コードの型エラーをチェックする
- コード内の型はTypeScriptが出力するJavaScriptに影響を与えることができない
- TypeScriptの型を実行時に確認することはできない
	- JavaScriptへのコンパイルの一部として、インターフェイス、型、型注釈をすべてコードから削除する
- 実行時に型情報を取得するための方法として、kindのようなプロパティを型に持たせ、それを用いて判別するタグ付き/判別ユニオン（tagged/discriminated unions）がTypeScriptでは広く使用されている
- classキーワードのように型（実行時に取得できない）と値（実行時に利用できる）の両方を導入する構文を使うこともできる
- タイプエラーのあるコードは出力を生成できる
	- コードの出力は型チェックとは独立しているため、型エラーのあるコードでも出力が生成される可能性がある
- TypeScriptのエラーはすべて、CやJavaのような「型チェックと出力が密接に関連している」言語の警告に似ている
	- エラー自体は問題を示している可能性が高く調査する価値があるが、ビルドを停止させることはない
- TypeScriptでよく聞く「コンパイルができない」という表現は不適切で、正しくは「コードにエラーがある」、もしくは「型チェックが出来ない」という方が適切
	- TypeScriptが有効なJavaScriptである限り、TypeScriptコンパイラは出力を生成するから
- エラーがある場合でもコードが生成されることで、問題を修正する前にアプリケーションの他の部分をテストすることができる
- コードをコミットする際には、エラーをゼロにすることを目指すべき
	- 予期されるエラーと予期されないエラーを覚えておく必要が出てきてしまうから
- 型操作は実行時の値に影響を与えることはできない
	- `as number`は型アサーションであり、キャストではない
- 実行時の型は宣言された型と同一であるとは限らない
	- 関数がネットワーク呼び出しなどから得られる値で呼び出される場合、予期しない型や値を含む可能性がある
	- 実行時の型が宣言された型と一致しない場合、非常に混乱を招く可能性がある
	- 不健全な型は可能な限り避けるべきだが、宣言された型とは異なる型を値が実行時に持つ可能性があることは理解しておく必要がある
- TypeScriptの型に基づいて関数をオーバーロードすることはできない
	- C++のような言語では、パラメータが異なる複数のバージョンの関数を定義できる
		- 関数のオーバーロードと呼ばれる
		- TypeScriptではコード実行時の挙動がその型情報に依存しないため、こういった構造は使用できない
	- TypeScriptは関数のオーバーロード機能を提供しているが、完全に型レベルで動作する
		- 関数に複数の型シグネチャを指定することはできるが、実装は1つだけに限られる
- TypeScriptの型は実行時のパフォーマンスに影響を与えない
	- 型や型操作はJavaScriptを生成する際に消去されるため、実行時のパフォーマンスに影響を与えることはない

### 構造的型付けに慣れる
- 構造的型付けを十分に理解することでエラーと非エラーを理解し、より堅牢なコードを書くのに役立つ
- JavaScriptはダックタイピングであり、TypeScriptは構造的型付けを使用している
	- インターフェースに割り当て可能な値には、型宣言に明示的に列挙されたもの以外のプロパティが含まれる可能性がある
- クラスも構造的型付けの規則に従うことに注意する
	- 期待通りのクラスインスタンスが得られない可能性がある
- ユニットテストを容易にするために構造的型付けを使用できる

### any型の使用を制限する
- any型を使用すると、TypeScriptを使用する利点の多くが失われる
	- 型安全性が保証されない
	- 型による契約を破る
	- 型による補完やドキュメントの恩恵を受けられなくなる
- any型を使用すると、型設計が暗黙的になりその設計がどのようなものであるかが分からなくなってしまう
- any型は出来る限り使わない！

## 2. TypeScriptの型システム
### エディタを使用して型システムを調査し、探求する
- 型やメソッドから、その定義が行われている型宣言ファイルにジャンプし、動作モデルを確認することができる

### 型を値の集合として考える
- 変数には型があり、これは想定される値の集合体であると考えるのが最適
	- この集合は型のドメインと捉えられる
- 最小の集合は空の集合であり、値は含まれない
	- TypeScriptのnever型に対応する
		- never型の変数には値を代入できない

## 3. 型推論と制御フロー解析
- sample

## 4. タイプデザイン
- sample

## 5. 不健全性とあらゆるタイプ
- sample

## 6. ジェネリクスと型レベルプログラミング
- sample

## 7. TypeScriptのレシピ
- sample

## 8. 型宣言と@types
- sample

## 9. コードの記述と実行
- sample

## 10. 近代化と移行
- sample