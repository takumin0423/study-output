## これはなに
- [TSKaigi2024](https://tskaigi.org/)にオンライン参加したので、聴いたセッションの内容をまとめる
- 全部聴くことはできないので、興味があるセッションのみ

## フロントエンドもバックエンドもインフラも… 全てをTypeScriptで統一したらこうなった！
### TSを使うとどうなるか
- どんなデータが使われているのか、どんなデータが期待されているかが型のおかげでわかりやすい
	- 関数の引数、戻り値、オブジェクトのプロパティなど
- 型によるエラーはコンパイル時に出してくれるので、プログラムを実行しなくともエラーに気付ける

### 実際にどのような環境で開発を行っているか
- トグルホールディングスさんの1プロダクトではTSで統一
- フロントエンドはReact, バックエンドはHono, インフラはPulumi
- 依存関係が一方向
	- インフラストラクチャ層はサービス層からしか呼び出されないなど
- Github Codespacesを活用
	- 環境構築がボタンのクリックだけで実現できる
- モノレポ構成
	- 認知負荷が下がる
	- 管理コストが下がる
- 開発に関わる情報はすべてGithubに一元化
- CIでテストと同じように型チェックも行っている

### 型について
- バリデーションライブラリにはZodを採用している
- inferを使って、Zodで定義したスキーマから型を生成
- フロントエンドとバックエンドで型を共有
- 共通のディレクトリから型を参照
	- それぞれが別で型定義を持たなくて済む
	- 型が変更された場合の変更漏れがなくなる
- APIリクエストにおける型にはZodiosを採用
	- Zodのスキーマ定義を活用したAPI定義ができるツール
	- 型安全なAPIリクエスト/レスポンス

### 統一したらどうなったか
- フルスタックな開発者体験を得ることが可能
	- TSで統一しているので学習コストが低い
	- TSの経験がなく、フロントエンドの経験しかなかった登壇者でも現在はフルスタックに開発を行えている
- 開発する機能の難易度によっては作業量の違いが出るが、フロントエンドとバックエンドの分業によるタスクの偏りは減った
- 知識の共有が捗る
	- TSが共通言語としてあるので、TSわかるけどRubyわからないみたいなのがなくてやりやすい
	- バックエンドの開発で得た知見をフロントエンド開発に活かしたりなど

### 登壇者の個人的な感想
- 元々フルスタックに開発したいと考えていた
- TSの実務経験がなかったが、TSで統一された環境に入り半年程度でフルスタックな開発ができるようになった
- 半年で158件のPRを作った、それくらいクイックにTSに詳しくなることが出来た

## エンジニアの技術的な意思決定を支えるADR - LayerXの活用事例
### ADRとは？
- ソフトウェアやシステムの設計における意思決定を文書化するための手法の一つ
- プロジェクトのアーキテクチャに関する重要な意思決定やその背景、理由、代替手段などを記録するために使用される
- 将来の開発者やメンバーがプロジェクトの進化や変更に理解を持ちやすくなるといったメリットがある
- 概ね以下のような情報が含まれる
1. コンテキスト（Context）: 意思決定を行った背景や文脈に関する情報。プロジェクトの現状、問題点、要件などが含まれる
2. 意思決定（Decision）: 実際に行われた意思決定に関する情報。採用されたアーキテクチャの選択、採用しなかった代替手段などが含まれる
3. 結果（Consequences）: 意思決定の結果として期待される影響や将来の課題に関する情報。採用したアーキテクチャがどのようにプロジェクトに影響を与えるか、またその他の代替手段がどのような結果をもたらす可能性があるかなどが含まれる
4. ステータス（Status）: ADRがどのような状態にあるかを示す情報。進行中、完了、廃止などが含まれる

## 新サービス Progate Path の演習で TypeScript を採用して見えた教材観点からの利点と課題
### Progate Pathの教材でのTSの活用
- Progate Pathでは実務感を重視している
	- 実務感がある状態とは、受講者が何をすべきか決定する適切な範囲の自由度が与えられている状態
- ちょうどいい実務感の教材がなかったので内製している
- TS採用には以下のメリットがある
	- 型があるので、教えたい重要なことを簡単に教えられる
	- 学習のための情報が多い
	- ものづくりに取り掛かりやすい
- 難しい点
	- WebAPI、Node.jsのAPI、TypeScriptの型などで混在する可能性がある
	- 古いドキュメントが残っている
	- 複雑なモジュールシステム
- TSの世界だと教えづらいこと
	- 参照やメモリ管理
	- バイナリによるデータ表現
	- イミュータビリティ

## TypeScriptと型のパフォーマンス
### 型が重いとは？
- 型生成量のオーダーによって決まる
- ジェネリック型でのループや再帰を行うと、大量のType Instantiationが起こる
	- Type Instantiation: 型パラメータを埋めた型を作る
- 型の構造が大きいかではなくType Instantiationの回数によって型の重さが決まる

### どうすれば改善できる？
- 型パラメータを自分で固定（非推奨）
- 頻度の高くて軽いオーバーロード（シグネチャ）を上に
- 関数の型パラメータの指定と使用を分ける
- 必要に応じて、TypeScriptの計算に適したインターフェース設計が必要
- tsserverでtraceを実行するVSCode拡張があるので、それで型の計算をトレースする

## 感想
-  TSをフルスタックに活用するとどういったメリットがあるか、どういった課題があったかについての発表が結構多かった印象
	- 業界全体としてフルスタックTSの流れが来ている？
	- RailsやGoなどでBFFを立てて、Next.jsはフロントエンド専用で使うみたいな発表はほぼなかった、バックエンド特有の処理もTypeScriptで書ける下地が整ってきているのかも
- 型で重くなるという観点が今までのなかったので勉強になった、ただ結局計算量的に重い処理は型も当然重くなるよね、という話だった
	- 型引数にユニオン型を渡して、それを条件型で判定しているような処理の場合、渡すユニオン型が大きければ大きいほど計算量が増えてしまう
	- 登壇者の方は実際にTypeScriptコンパイラの内部コードまで読みにいったみたいなので、そういった骨太な解決方法が必要になる時が来るかも
	- 色々なデバッグツールについても紹介されていたので、一度自分でも使ってみる