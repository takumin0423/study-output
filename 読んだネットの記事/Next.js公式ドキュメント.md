## Guides
### Routing
#### Layouts and Templates
- レイアウトとは、複数のページ間で共有されるUI
	- ページ間をナビゲーションしても、レイアウトは状態を保持し、インタラクティブなままで再レンダリングされない
- `app`ディレクトリのルートに定義されるルートレイアウトは必須であり、 `<html>`タグと `<body>`タグを含める必要がある
- レイアウトは `children`プロパティを通じて子レイアウトをラップできる

#### Linking and Navigating
- Next.jsでルート間を移動するための4つの方法は以下の通り
	- `<Link>`コンポーネントを使用する
	- `useRouter`フックを使用する（クライアントコンポーネント）
	- `redirect`関数を使用する（サーバーコンポーネント）
	- ネイティブのHistory APIを使用する
- 特別な要件がない限り、ルート間のナビゲーションには `<Link>`コンポーネントの使用が推奨されている
- App Routerはルーティングとナビゲーションにハイブリッドアプローチを採用している
	- サーバー側では、アプリケーションコードがルートセグメント単位で自動的にコード分割される
	- クライアント側では、Next.js がルートセグメントをプリフェッチし、キャッシュする
	- これにより、ユーザーが新しいルートへ遷移する際にブラウザがページを再読み込みすることはなく、変更があったルートセグメントのみが再レンダリングされる
		- ナビゲーション体験とパフォーマンスが向上する

#### Error Handling
- 想定されたエラーは戻り値として扱う
	- Server Actionsでは、想定されるエラーに対して `try`/ `catch`を使わない
	- 代わりに `useActionState`を使用してエラーを管理し、クライアントに返す
- 予期しないエラーにはエラーバウンダリを使用する
	- 予期しないエラーとは、アプリケーションの通常の処理の流れでは発生しないはずのバグや問題を示すもの
		- `throw`でエラーを発生させ、それをエラーバウンダリで補足する形で処理する
	- `error.tsx`および `global-error.tsx`を使用してエラーバウンダリを実装し、予期しないエラーを処理してフォールバックUIを表示する
- サーバーコンポーネント内でデータを取得する際には、レスポンスを利用して条件に応じてエラーメッセージを表示したり、リダイレクトを実行したりできる
- 想定されたエラーとは、アプリケーションの通常の動作中に発生する可能性があるエラーのこと
	- サーバーサイドのフォームバリデーションエラーやリクエストの失敗など
- キャッチされない例外とは、アプリケーションの通常の処理の流れでは発生しないはずのバグや問題を示す予期しないエラー
	- `throw`でエラーを発生させ、それをエラーバウンダリで補足する形で処理する
- エラーバウンダリは、その子コンポーネント内で発生したエラーをキャッチし、クラッシュししたコンポーネントツリーの代わりにフォールバックUIを表示する
	- エラーが親のエラーバウンダリまで伝播するようにしたい場合は、 `error.tsx`内でレンダリング時にエラーを再スローできる
- エラーは最も近い親のエラーバウンダリまでバブルアップ（伝播）する
	- ルート階層の様々なレベルに `error.tsx`を配置することで、きめ細やかなエラー処理が可能になる
- `app/global-error.tsx`を使ってルートレイアウト内のエラーを処理することができる
	- あまり一般的ではない

#### Loading UI and Streaming
- `loading.tsx`という特別なファイルを使うことで、ReactのSuspenseと連携した意味のあるローディングUIを作成できる
- インスタントローディングステートとは、ナビゲーション直後に即座に表示されるフォールバックUIのこと
	- スケルトンやスピナーなどのローディングインジケーター、カバーフォトやタイトルなど将来的に表示される画面の一部を先に表示することで、アプリが反応していることをユーザーに伝え、より良いユーザー体験を提供できる
- `loading.tsx`をフォルダ内に追加することで、 `loading.tsx`は `layout.tsx`の内部にネストされ、 `page.tsx`やその下層のコンポーネントを自動的に `<Suspense>`でラップする
- **Next.jsはこの機能を最適化しているため、ルートセグメント（layoutsやpages）に対して `loading.tsx`を慣習的に使用することを推奨する**
- SSRでユーザーがページを見て操作できるようになるまでに、以下のような一連の処理が順番に行われる
	- ページに必要な全てのデータをサーバーで取得する
	- サーバーがそのデータを元にHTMLを生成する
	- HTML, CSS, JavaScriptがクライアントに送信される
	- サーバーで生成されたHTMLとCSSを使って、非インタラクティブなUIが表示される
	- 最後にReactがハイドレーションを行い、UIがインタラクティブになる
- 上記のステップは逐次的かつブロッキングなので、すべてのデータが取得されてからでないとサーバーはページのHTMLをレンダリングできない
	- クライアント側もページ内のすべてのコンポーネントのコードがダウンロードされてからでないと、ReactはUIをハイドレート（インタラクティブ化）できない
- ReactとNext.jsにおけるSSRは、非インタラクティブなページを出来るだけ早くユーザーに表示することで、体感的な読み込み速度の向上に貢献する
- ページのHTMLを小さなチャンクに分割し、それらをサーバーからクライアントへ段階的に送信するストリーミングは、時間のかかるデータリクエストによってページの表示がブロックされるのを防ぎたい場合に特に有効
	- TTFB（Time To First Byte）やFCP（First Contentful Paint）を短縮できる
	- 特に処理能力の低いデバイスにおいてはTTI（Time To Interactive）の改善にも役立つ
- Suspenseを使用することで、以下のような利点を得られる
	- サーバーからクライアントへHTMLを段階的にレンダリングして送信できる
	- Reactがユーザーの操作に基づいて優先的にインタラクティブにすべきコンポーネントを判断し、ハイドレーションの順序を最適化する
- ストリーミングはサーバーサイドでレンダリングされるため、SEOに影響はない
- ストリーミング時には、リクエストが成功したことを示す200ステータスコードが返される
	- ただし、サーバーはストリーミングコンテンツ内でクライアントにエラーや処理の内容を通知することも可能
		- `redirect`や `notFound`の使用時など

#### Redirecting
- `redirect`関数は、Server Components, Route Handlers, Server Actionsの中で呼び出せる
	- ユーザーを別のURLへリダイレクトさせるために使用され、投稿の作成後などの何らかの操作の後に使われることが一般的
- `redirect`はデフォルトでステータスコード307（Temporary Redirect）を返す
	- ただしServer Actions内で使用した場合は303（See Other）を返し、これはPOSTリクエスト後に成功ページへリダイレクトする際によく使われる
- `redirect`は内部的に例外をスローするため、 `try`/ `catch`ブロックの外で呼び出す必要がある
- `redirect`は絶対URLにも対応していて、外部リンクへのリダイレクトにも使用できる
- `permanentRedirect`関数は、ユーザーを別のURLへ恒久的にリダイレクトするために使用される
	- ユーザー名を変更した際にプロフィールURLが代わるなど、エンティティの正規URLが変更される操作の後に使用されることが一般的
- `permanentRedirect`はデフォルトでステータスコード308（Permanent Redirect）を返す
- `next.config.ts`ファイル内の `redirects`オプションは、受信リクエストのパスを別の宛先パスへリダイレクトするために使用される
	- ページのURL構造を変更した場合や、事前に知られているリダイレクトのリストがある場合に便利
- Middlewareを使用すると、リクエストが完了する前にコードを実行できる
	- 受信リクエストに基づいて `NextResponse.redirect`を使い、別のURLにリダイレクトすることが可能
	- 認証やセッション管理などの条件に基づいてユーザーをリダイレクトしたい場合や、大量のリダイレクトを処理したい場合に便利

#### Route Groups
- フォルダを丸括弧（`()`）で囲むことでそのフォルダをルートグループとしてマークし、ルートのURLパスに含まれないようにできる
	- ルートセグメントやプロジェクトファイルを論理的なグループに整理しつつ、URLパス構造に影響を与えないようにすることが可能
		- サイトのセクション、チーム別などでルートを整理したい時や同一のルートセグメントレベルでネストされたレイアウトを有効にしたい時などに使う

#### Dynamic Routes
- 動的セグメントは、フォルダ名を角括弧（`[]`）で囲むことで作成できる
	- `app/blog/[slug]/page.tsx`のようなルートがあった場合、 `[slug]`はブログ投稿のための動的セグメント
	- 動的セグメントは、layout, page, route, `generateMetadata`関数に `params`プロパティとして渡される
- `params`プロパティはPromiseなので、値にアクセスするには `async`/ `await`またはReactの `use`関数を使用する必要がある
	- v14以前では `params`は同期的なプロパティで、後方互換性を保つためにv15でも引き続き同期的にアクセスできるが、将来的に非推奨になる予定

#### Parallel Routes
- Parallel Routesは、同じレイアウト内で複数のページを同時に、または条件付きでレンダリングすることを可能にする
	- ダッシュボードやソーシャルサイトのフィードなど、非常に動的なセクションを持つアプリで特に便利
- Parallel Routesは `@folederName`という命名規則で定義される名前付きスロットを使用して作成する
	- スロットは共通の親レイアウトにpropsとして渡される
	- スロットはルートセグメントではないため、URL構造には影響しない
- `children`プロパティは暗黙的なスロット
	- `app/page.tsx`は `app/@children/page.tsx`と同等
- 後述するIntercepting Routesと組み合わせることで、ディープリンクに対応したモーダルを作成できる

#### Intercepting Routes
- Intercepting Routesを使用すると、アプリケーション内の別の部分のルートを現在のレイアウト内で読み込むことができる
	- ユーザーに異なるコンテキストへ遷移させずにルートの内容を表示したい場合に便利
- Parallel Routesと組み合わせてモーダルを構築すると、モーダルを実装する際によくある以下の課題を解決できる
	- モーダルの内容をURL経由で共有可能にする
	- ページをリフレッシュした際に、モーダルを閉じることなくコンテキストを保持する
	- 「戻る」操作でモーダルを閉じ、前のルートに戻るのを防ぐ
	- 「進む」操作でモーダルを再び開く

#### Route Handlers
- Route Handlersを使用すると、WebのRequestおよびResponse APIを用いて、特定のルートに対するカスタムリクエストハンドラーを作成することができる
	- 要するにAPIエンドポイントを作れるってこと
- Route Handlersは `app`ディレクトリ内の `route.ts`ファイルで定義する
	- `page.tsx`や `layout.tsx`と同様に、 `app`ディレクトリ内の任意の場所にネストして配置できる
	- 同一ルートセグメント内に `page.tsx`と `route.ts`を同時に存在させることはできない
- Route Handlersはデフォルトではキャッシュされない
	- GETメソッドに限り、Route Handlersファイル内で以下のようにすることでキャッシュを有効に出来る
```ts
export const dynamic = 'force-static'
```
- 同じファイル内でGETメソッドをキャッシュしていても、他のHTTPメソッドはキャッシュされない

#### Middleware
- ミドルウェアは、リクエストが完了する前にコードを実行できる
- 受信したリクエストに基づいて、以下のようなレスポンスの変更が可能
	- リクエストの書き換え
	- リダイレクト
	- リクエストやレスポンスのヘッダー変更
	- 直接レスポンスを返す
- ミドルウェアは、キャッシュされたコンテンツやルートがマッチされる前に実行される
- ミドルウェアが効果的に機能する代表的なシナリオ
	- リクエストの一部を読み取った後の迅速なリダイレクト
	- A/Bテストや実験に基づいて、別のページに書き換える
	- すべてのページまたは一部のページのヘッダーを変更する
- ミドルウェアが適していない用途
	- 遅延があるデータ取得
	- セッション管理
- ミドルウェアは、プロジェクトのルートにある `middleware.ts`で定義する
	- ロジック自体はモジュール的に分割して整理可能
		- 各種ミドルウェアの機能を個別の.tsファイルに分割
		- それらをメインの `middleware.ts`にインポート
- ミドルウェアは、プロジェクト内のすべてのルートに対して呼び出される
	- 特定のルートだけを対象にしたり、除外するためにはmatcherを使う必要がある
- ミドルウェアの実行順序
	- `next.config.ts`の `headers`
	- `next.config.ts`の `redirects`
	- ミドルウェア（書き換え、リダイレクトなど）
	- `next.config.ts`の `beforeFiles`
	- ファイルシステムルート（`public/`, `_next/static/`, `pages/`, `app/`など）
	- `next.config.ts`の `afterFiles`
	- 動的ルート（例 : `/blog/[slug]`）
	- `next.config.ts`の `fallback`
- ミドルウェアがどのパスで実行されるかを定義する方法は2つある
	- カスタムマッチャー設定
		- `middleware.ts`内で `config.matcher`を使って、対象ルートを明示的に指定する
	- 条件文
		- ミドルウェア関数内で `request.nextUrl.pathname`などを用いた条件分岐により、特定のルートでのみ処理を実行するよう制御する
- matcherの値はビルド時に静的解析されるため、定数である必要がある
	- 変数などの動的な値は無視される
- matcherに指定する値は必ずスラッシュ（`/`）から始める必要がある
- `NextResponse`APIを使用すると、以下のような処理が可能になる
	- リクエストを別のURLにリダイレクト
	- 指定したURLの内容でレスポンスを書き換え
	- API Routesや `getServerSideProps`, リライト先のルートに対してリクエストヘッダーを設定
	- レスポンスにクッキーを設定
	- レスポンスヘッダーを設定
- Next.jsでは、 `NextRequest`と `NextResponse`に拡張された `cookies`を通じて、クッキーへのアクセスや操作を行える
	- リクエストでは、クッキーは `Cookie`ヘッダーに格納される
	- レスポンスでは、クッキーは `Set-Cookie`ヘッダーに格納される
- ミドルウェアはデフォルトでEdge Runtimeを使用する
- Next.js v15.2（Canary）ではNode.jsランタイムの実験的サポートが追加
	- まだ本番環境での使用は非推奨

#### Internationalization
- ブラウザ内のユーザーの言語設定を使用してどのロケールを使用するかを選択することが推奨されている
- `app/`ディレクトリ内のすべてのレイアウトおよびページは、デフォルトでサーバーコンポーネントとして動作するため、翻訳ファイルのサイズがクライアント側のJavaScriptバンドルサイズに影響を与えることはない

### Data Fetching
#### Data Fetching and Caching
- `fetch`によるレスポンスは、デフォルトではキャッシュされない
- ルート内で `fetch`以外に動的なAPIを使用していない場合、そのページは `next build`の際にプリレンダリングされ、静的ページとして生成される
	- その後、データはIncremental Static Regeneration（ISR）によって更新可能
- ページのプリレンダリングを防ぎたい場合は、以下のコードをファイルに追加する
```tsx
export const dynamic = 'force-dynamic'
```
- 通常は `cookies`, `headers`, ページのpropsから渡される `searchParams`を読み込む関数などを使用することが多く、それらによってページは自動的に動的なものとしてレンダリングされる
	- このような場合は `force-dynamic`を明示的に使用する必要はない
- データベースからのレスポンスはデフォルトではキャッシュされないが、追加の設定によってキャッシュ可能
	- `unstable_cache`APIを使い、データベースクエリの結果をどれくらいキャッシュするのか、タグをつけるのかを指定する
- クライアント側でのデータ取得ではなく、サーバー側でのデータ取得推奨
	- どうしてもクライアント側でのデータ取得が必要な場合は、SWRやReact Queryなどコミュニティで広く採用されているReactライブラリを利用する
- `fetch`を使用している場合、オプションとして `cache: 'force-cache`を追加することでリクエストのメモ化が可能
	- 同じURL, 同じオプションで呼び出した場合に、実際のリクエストは一回のみ実行されるようになる
- `fetch`を使用せず、ORMなどを使っている場合はReactの `cache`関数でデータ取得処理をラップすることでクエリが重複せず一度だけ実行されるようになる
- v15以前では `fetch`のデフォルトキャッシュ値は `force-cache`だったが、v15以降ではデフォルトが `no-store`に変更されている
- コンポーネントツリー内でリクエストが互いに依存している場合、データの取得は逐次的に行われ、読み込み時間が長くなる可能性がある
	- ネストされた各コンポーネントがそれぞれのデータを取得し、リクエストがメモ化されていない場合など
	- ユーザー体験を損なわないために、 `loading.tsx`やReactのSuspenseを使って即座にローディング状態を表示することができる
		- データ取得によってルート全体がブロックされることを防ぎ、表示可能な部分だけでも早期にユーザーに表示させることが可能になる