## Guides
### Routing
#### Layouts and Templates
- レイアウトとは、複数のページ間で共有されるUI
	- ページ間をナビゲーションしても、レイアウトは状態を保持し、インタラクティブなままで再レンダリングされない
- `app`ディレクトリのルートに定義されるルートレイアウトは必須であり、 `<html>`タグと `<body>`タグを含める必要がある
- レイアウトは `children`プロパティを通じて子レイアウトをラップできる

#### Linking and Navigating
- Next.jsでルート間を移動するための4つの方法は以下の通り
	- 1. `<Link>`コンポーネントを使用する
	- 2. `useRouter`フックを使用する（クライアントコンポーネント）
	- 3. `redirect`関数を使用する（サーバーコンポーネント）
	- 4. ネイティブのHistory APIを使用する
- 特別な要件がない限り、ルート間のナビゲーションには `<Link>`コンポーネントの使用が推奨されている
- App Routerはルーティングとナビゲーションにハイブリッドアプローチを採用している
	- サーバー側では、アプリケーションコードがルートセグメント単位で自動的にコード分割される
	- クライアント側では、Next.js がルートセグメントをプリフェッチし、キャッシュする
	- これにより、ユーザーが新しいルートへ遷移する際にブラウザがページを再読み込みすることはなく、変更があったルートセグメントのみが再レンダリングされる
		- ナビゲーション体験とパフォーマンスが向上する

#### Error Handling
- 想定されたエラーは戻り値として扱う
	- Server Actionsでは、想定されるエラーに対して `try`/ `catch`を使わない
	- 代わりに `useActionState`を使用してエラーを管理し、クライアントに返す
- 予期しないエラーにはエラーバウンダリを使用する
	- 予期しないエラーとは、アプリケーションの通常の処理の流れでは発生しないはずのバグや問題を示すもの
		- `throw`でエラーを発生させ、それをエラーバウンダリで補足する形で処理する
	- `error.tsx`および `global-error.tsx`を使用してエラーバウンダリを実装し、予期しないエラーを処理してフォールバックUIを表示する
- サーバーコンポーネント内でデータを取得する際には、レスポンスを利用して条件に応じてエラーメッセージを表示したり、リダイレクトを実行したりできる
- 想定されたエラーとは、アプリケーションの通常の動作中に発生する可能性があるエラーのこと
	- サーバーサイドのフォームバリデーションエラーやリクエストの失敗など
- キャッチされない例外とは、アプリケーションの通常の処理の流れでは発生しないはずのバグや問題を示す予期しないエラー
	- `throw`でエラーを発生させ、それをエラーバウンダリで補足する形で処理する
- エラーバウンダリは、その子コンポーネント内で発生したエラーをキャッチし、クラッシュししたコンポーネントツリーの代わりにフォールバックUIを表示する
	- エラーが親のエラーバウンダリまで伝播するようにしたい場合は、 `error.tsx`内でレンダリング時にエラーを再スローできる
- エラーは最も近い親のエラーバウンダリまでバブルアップ（伝播）する
	- ルート階層の様々なレベルに `error.tsx`を配置することで、きめ細やかなエラー処理が可能になる
- `app/global-error.tsx`を使ってルートレイアウト内のエラーを処理することができる
	- あまり一般的ではない

#### Loading UI and Streaming
- `loading.tsx`という特別なファイルを使うことで、ReactのSuspenseと連携した意味のあるローディングUIを作成できる
- インスタントローディングステートとは、ナビゲーション直後に即座に表示されるフォールバックUIのこと
	- スケルトンやスピナーなどのローディングインジケーター、カバーフォトやタイトルなど将来的に表示される画面の一部を先に表示することで、アプリが反応していることをユーザーに伝え、より良いユーザー体験を提供できる
- `loading.tsx`をフォルダ内に追加することで、 `loading.tsx`は `layout.tsx`の内部にネストされ、 `page.tsx`やその下層のコンポーネントを自動的に `<Suspense>`でラップする
- **Next.jsはこの機能を最適化しているため、ルートセグメント（layoutsやpages）に対して `loading.tsx`を慣習的に使用することを推奨する**
- SSRでユーザーがページを見て操作できるようになるまでに、以下のような一連の処理が順番に行われる
	- 1. ページに必要な全てのデータをサーバーで取得する
	- 2. サーバーがそのデータを元にHTMLを生成する
	- 3. HTML, CSS, JavaScriptがクライアントに送信される
	- 4. サーバーで生成されたHTMLとCSSを使って、非インタラクティブなUIが表示される
	- 5. 最後にReactがハイドレーションを行い、UIがインタラクティブになる
- 上記のステップは逐次的かつブロッキングなので、すべてのデータが取得されてからでないとサーバーはページのHTMLをレンダリングできない
	- クライアント側もページ内のすべてのコンポーネントのコードがダウンロードされてからでないと、ReactはUIをハイドレート（インタラクティブ化）できない
- ReactとNext.jsにおけるSSRは、非インタラクティブなページを出来るだけ早くユーザーに表示することで、体感的な読み込み速度の向上に貢献する
- ページのHTMLを小さなチャンクに分割し、それらをサーバーからクライアントへ段階的に送信するストリーミングは、時間のかかるデータリクエストによってページの表示がブロックされるのを防ぎたい場合に特に有効
	- TTFB（Time To First Byte）やFCP（First Contentful Paint）を短縮できる
	- 特に処理能力の低いデバイスにおいてはTTI（Time To Interactive）の改善にも役立つ
- Suspenseを使用することで、以下のような利点を得られる
	- サーバーからクライアントへHTMLを段階的にレンダリングして送信できる
	- Reactがユーザーの操作に基づいて優先的にインタラクティブにすべきコンポーネントを判断し、ハイドレーションの順序を最適化する
- ストリーミングはサーバーサイドでレンダリングされるため、SEOに影響はない
- ストリーミング時には、リクエストが成功したことを示す200ステータスコードが返される
	- ただし、サーバーはストリーミングコンテンツ内でクライアントにエラーや処理の内容を通知することも可能
		- `redirect`や `notFound`の使用時など

#### Redirecting
- `redirect`関数は、Server Components, Route Handlers, Server Actionsの中で呼び出せる
	- ユーザーを別のURLへリダイレクトさせるために使用され、投稿の作成後などの何らかの操作の後に使われることが一般的
- `redirect`はデフォルトでステータスコード307（Temporary Redirect）を返す
	- ただしServer Actions内で使用した場合は303（See Other）を返し、これはPOSTリクエスト後に成功ページへリダイレクトする際によく使われる
- `redirect`は内部的に例外をスローするため、 `try`/ `catch`ブロックの外で呼び出す必要がある
- `redirect`は絶対URLにも対応していて、外部リンクへのリダイレクトにも使用できる
- `permanentRedirect`関数は、ユーザーを別のURLへ恒久的にリダイレクトするために使用される
	- ユーザー名を変更した際にプロフィールURLが代わるなど、エンティティの正規URLが変更される操作の後に使用されることが一般的
- `permanentRedirect`はデフォルトでステータスコード308（Permanent Redirect）を返す
- `next.config.ts`ファイル内の `redirects`オプションは、受信リクエストのパスを別の宛先パスへリダイレクトするために使用される
	- ページのURL構造を変更した場合や、事前に知られているリダイレクトのリストがある場合に便利
- Middlewareを使用すると、リクエストが完了する前にコードを実行できる
	- 受信リクエストに基づいて `NextResponse.redirect`を使い、別のURLにリダイレクトすることが可能
	- 認証やセッション管理などの条件に基づいてユーザーをリダイレクトしたい場合や、大量のリダイレクトを処理したい場合に便利

#### Route Groups
- フォルダを丸括弧（`()`）で囲むことでそのフォルダをルートグループとしてマークし、ルートのURLパスに含まれないようにできる
	- ルートセグメントやプロジェクトファイルを論理的なグループに整理しつつ、URLパス構造に影響を与えないようにすることが可能
		- サイトのセクション、チーム別などでルートを整理したい時や同一のルートセグメントレベルでネストされたレイアウトを有効にしたい時などに使う